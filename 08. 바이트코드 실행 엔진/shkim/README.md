# 바이트코드 실행 엔진

실행 엔진은 자바 가상 머신의 핵심 구성 요소다. <br>
가상 머신의 실행 엔진은 순수하게 소프트웨어로만 구현된다. 따라서 명령어 집합의 구조와 실행 엔진을 물리적 제약 없이 원하는 대로 만들 수 있다. <br>
하드웨어에서 직접 지원하지 않는 명령어 집합도 실행할 수 있다는 뜻이다.

## 런타임 스택 프레임 구조

자바 가상 머신은 메서드를 가장 기본적인 실행 단위로 사용하며, 메서드 호출과 실행을 뒷받침하는 내부 데이터 구조로 스택 프레임을 이용한다. <br>
스택 프레임에는 메서드의 지역 변수 테이블, 피연산자 스택, 동적 링크, 반환 주소와 같은 정보가 담긴다. <br>
메서드 호출 시작부터 실행 종료까지 과정은 스택 프레임을 가상 머신 스택으로 푸시하는 작업에 해당한다.

스택 프레임 각각에는 지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환 주소와 몇 가지 추가 정보가 담겨 있다. <br>
스택 프레임에 할당해야 하는 메모리 크기는 프로그램 실행 중에는 영향을 받지 않고, 오로지 프로그램 소스 코드와 특정 가상 머신 구현의 스택 메모리 레이아웃에 달려 있다. <br>
실행 엔진이 실행하는 모든 바이트코드 명령어는 현재 스택 프레임에서만 작동한다.

<img width="479" alt="Image" src="https://github.com/user-attachments/assets/5a091200-a632-4353-9667-622b64647540" />

### 지역 변수 테이블

지역 변수 테이블은 메서드 매개 변수와 메서드 안에서 정의된 지역 변수를 저장하는 공간이다. <br>
지역 변수 테이블의 용량 기준은 가장 작은 단위 인 변수 슬롯이다. <br>
변수 슬롯은 32비트 이하의 데이터 타입을 저장할 수 있으며 자바에서 32비트 이하의 공간을 차지하는 데이터 타입은 boolean, byte, char, short, int, float, 참조 타입, returnAddress다.
returnAddress은 바이트코드 명령어 jsr, jsr_w, ret에 다른 바이트코드 명령어의 주소를 알려주는 용도로 쓰인다. <br>
지역 변수 테이블은 스레드 스택에 스레드별로 따로 만들어지기 때문에 데이터 경합이나 스레드 안전 문제는 생기지 않는다.

### 피연산자 스택

피연산자 스택은 후입선출 스택이다. 피연산자 스택의 각 원소에는 Sng과 double까지 포함한 모든 자바 데이터 타입을 담을 수 있다. <br>
메서드가 막 실행되기 시작할 때는 해당 메서드의 피연산자 스택이 비어 있다. <br>
그리고 실행하는 동안 다양한 바이트코드 명령어가 스택에 내용을 쓰거나(푸시) 값을 읽어 온다(팝). <br>
예를 들어 산술 연산을 수행할 때는 연산에 수반되는 피연산자 값을 스택 맨 위에 푸시한 다음 연산을 수행한다. 또한 다른 메서드를 호출할 때는 매개 변수를 피연산자 스택을 통해 전달한다.

개념 모델에서 서로 다른 메서드의 가상 머신 스택에 있는 스택 프레임들은 완전히 독립적이다. <br>
하지만 대부분의 가상 머신에서는 최적화 과정에서 스택 프레임들을 부분적으로 겹쳐 사용한다. <br>
하부 스택 프레임의 피연산자 스택 일부가 상부 스택 프레임의 지역 변수 테이블과 겹쳐지는 것이다. <br>
이렇게 하면 공간이 절약되고, 더 중요하게는 메서드 호출 시 매개 변수로 전달할 데이터를 복사할 필요가 없어진다.

<img width="608" alt="Image" src="https://github.com/user-attachments/assets/f2ea9b89-a68d-445e-97b3-09e11a78555e" />

### 동적 링크

메서드에서 이용하는 외부 객체를 가리키는 참조는 런타임 상수 풀에 담겨 있으며, 각 메서드의 스택 프레임에서 런타임 상수 풀 내의 원소를 참조하는 식으로 구성된다. <br>
이 참조가 동적 링크를 가능하게 하는 매개다. 

### 반환 주소

시작된 메서드를 종료하는 방법은 두 가지뿐이다.

1. 실행 엔진이 반환 바이트코드 명령어를 만나면 메서드를 종료한다. 이때 호줄자에 반환값이 전달될 수 있는데, 반환값 유무와 반환값의 타입은 메서드 반환 명령어에 의해 결정된다.
2. 메서드 실행 도중 예외가 발생하고 메서드 본문에서 예외 처리가 제대로 이루어지지 않으면 종료된다.

둘 중 어떤 식으로든 메서드가 종료되면 메서드를 호출한 위치로 돌아가야 한다. <br>
메서드가 반환되면 호출자의 실행 상태를 복원하기 위해 스택 프레임에 정보 일부를 저장해야 할 수 있다. <br>
일반적으로 메서드가 정상 종료되면 호출자의 프로그램 카운터 값을 반환 주소로 사용할 수 있다. 이 카운터 값은 스택 프레임 에 저장될 가능성이 높다. <br>
메서드가 비정상 종료되면 예외 핸들러 테이블에 의해 반환 주소가 결정된다. 이 정보는 일반적으로 스택 프레임에 저장되지 않는다.

## 메서드 호출

메서드 호출은 메서드 본문 코드를 실행하는 일과 다르다. <br>
메서드 호출 단계에서 수행하는 유일한 일은 호출할 메서드의 버전을 선택하는 것이다. <br>
자바는 동적 확장 측면에서 여타 언어보다 뛰어나지만 메서드 호출 과정이 상대적으로 복잡해졌다. <br>
때에 따라 클래스 로딩 시점에 또는 심지어 런타임에 대상 메서드의 직접 참조를 알아내야 한다.

### 해석

메서드 호출 대상은 모두 클래스 파일의 상수 풀에 심벌 참조로 기록되어 있다. <br>
어떤 메서드는 호출할 버전을 프로그램이 실행되기 전에 알아낼 수 있으며 런타임에는 다른 버전으로 변경될 수 없다. <br>
즉, 컴파일러가 프로그램 코드를 컴파일하는 시점에 호출 대상이 정해진다. (정적 해석)

자바 언어에서 "컴파일타임에 알 수 있고 런타임에는 변경될 수 없다"라는 조건에 부합하는 메서드는 주로 정적 메서드와 private 메서드다. <br>
정적 메서드는 특정 클래스에 고정되어 있고, private 메서드는 인스턴스 바깥에서는 접근할 수 없다. <br>
따라서 두 유형의 메서드 모두 상속 등을 통해 다른 버전을 만들 수 없으므로 클래스 로딩 단계에서 해석하기에 적합하다.

### 디스패치

호출 디스패치 과정은 자바 가상 머신에서 오버로딩과 오버라이딩이 구현되는 방식처럼 다형성이라는 특성의 가장 기본에 해당하는 내용이다. 

#### 정적 디스패치

<img width="677" alt="Image" src="https://github.com/user-attachments/assets/82c2f86e-a065-44e6-a5d2-5147f632c43e" />

```
Hello, guy!
Hello, guy!
```

위 코드 실행 결과는 다음과 같다. <br>
Human을 변수의 정적 타입, 겉보기 타입이라고 하고, Man을 실제 타입, 런타임 타입이라고 한다. <br> 
정적 타입은 변수가 사용될 때만 변경되며, 변수 자체의 정적 타입은 변하지 않는다. <br>
그리고 최종 정적 타입은 컴파일타임에 알 수 있는 반면, 타입 변경의 결과는 런타임에 결정되기 때문에 컴파일러는 객체의 실제 타입이 무엇인지 알지 못한다.

```java
// 실제 타입 변경
Human human = (new Random()).nextBoolean() ? new Man() : new Woman();

// 정적 타입 변경
sr.sayHello((Man) human)
sr,sayHello((Woman) human)
```

human 객체의 실제 타입은 변경될 수 있으니 컴파일 중에는 완전히 슈뢰딩거의 고양이다. <br>
실제 타입이 Man일지 Woman일지는 프로그램이 이 코드 라인을 실행할 때에야 마침내 선택 된다. <br>
반면 human 객체의 정적 타입은 Human이며 마찬가지로 사용 중에 변경될 수 있다. 하지만 이 변경은 컴파일타임에 알 수 있다. <br>
앞의 코드에서는 sayHello() 메서드를 호출할 때 강제로 변환했기 때문에 변환 결과가 Man인지 Woman인지가 컴파일타임에 명확히 정해진다.

<br>

```java
public static void main(String[] args) {
        Human man = new Man(); // 정적 타입 = Human, 실제 타입 = Man
        Human woman = new Woman(); // 정적 타입 = Human, 실제 타입 = Woman
        StaticDispatch sr = new StaticDispatch();
        sr.sayHello(man); // 메서드 버전 선택 필요
        sr.sayHello(woman); // 메서드 버전 선택 필요    
}
```

메서드 수신자인 sr 객체가 선택되어 있다고 가정하면,  오버로딩된 메서드 중 어느 버전을 호출할지는 전적으로 매개 변수의 수와 타입이 기준이다. <br>
이 코드에서 man과 woman은 정적 타입 이 같지만 실제 타입은 다르게 정의했다. <br>
**하지만 가상 머신은 호출할 sayHello()를 선택할 때 매개변수의 실제 타입이 아닌 정적 타입을 참고한다.** <br>
정적 타입은 컴파일타임에 알려지기 때문에 javac 컴파일러는 매개 변수의 정적 타입을 보고 어떤 오버로딩 버전을 호출할지 선택한다. <br>
따라서 sayHello(Human)이 호출 대상으로 선택되고, 이 메서드의 심벌 참조가 main() 메서드의 두 invokevirtual 명령어의 매개변수로 기록된다.

메서드 버전 선택에 정적 타입을 참고하는 모든 디스패치 작업을 정적 디스패치라고 한다. <br>
정적 디스패치는 컴파일타임에 이루어지므로 지금 설명한 선택 작업은 가상 머신에서는 이루어지지 않는다.

#### 동적 디스패치

다음은 자바의 다형성, 즉 오버라이딩과 밀접하게 관련된 또 다른 주제인 동적 디스패치의 작동 과정을 살펴본다. <br>

<img width="520" alt="Image" src="https://github.com/user-attachments/assets/eb0e2f7a-023b-4cf7-95e9-819fa030e0f5" /> <br>
<img width="660" alt="Image" src="https://github.com/user-attachments/assets/37a192f3-9069-404b-a752-31fc964916f2" />

```
Man said hello
Woman said hello
Woman said hello
```

실행 결과는 다음과 같다. <br>
이번 예에서는 호출할 메서드의 버전을 정적 타입만으로 결정하기가 불가능하다. <br>
변수 man과 woman의 정적 타입은 모두 Human으로 똑같지만, sayHello()를 호출하면 서로 다른 메서드를 호줄하기 때문이다. <br>
심지어 man 변수의 경우 두 번째 호출 시에는 처음과 다른 메서드를 호출한다.

둘 다 메서드 호출 명령어는 invokevirtual이다. 하지만 실행될때 호출하는 실제 메서드는 다르다. <br>
이 상황을 이해하는 핵심은 invokevirtual 명령어가 후보 메서드들을 찾아 그중 하나를 특정하여 다형성을 구현하는 방식에 있다. <br>
invokevirtual 명령어의 런타임 해석은 대략 다음 4단계로 이루어진다.

1. 피연산자 스택 상단 첫 번째 요소가 가리키는 객체의 실제 타입을 찾는다.
2. 타입에서 상수의 서술자 및 단순 이름과 일치하는 메서드를 찾으면 접근 권한이 있는지 검사한다. 권한이 있다면 이 메서드의 직접 참조를 반환하고 검색을 끝낸다. 권한이 없다면 IllegalAccessError를 던진다.
3. 그렇지 않으면 상속 계층을 따라 아래에서 위로 타입의 상위 클래스에 대해 2번 과정을 수행한다.
4. 최상위 클래스까지도 적절한 메서드를 찾지 못하면 AbstractMethodError를 던진다.

## 동적 타입 언어 지원

동적 타입 언어의 핵심 특징은 타입 검사 과정 중 주요 단계들이 런타임에 수행된다는 것이다. <br>
컴파일러가 컴파일타임에 결정할 수 있는 정보는 기껏해야 메서드 이름, 매개 변수, 반환값이다. <br>
메서드의 구체적인 타입은 정해지지 않는다. 메서드 수신 객체가 특정되지 않는다는 뜻이다. <br>
이러한 특성을 변수에는 타입이 없고 변수의 값에만 타입이 있다 라고 말한다. <br>
이 점이 바로 동적 타입 언어의 핵심 특성이다.

### 자바와 동적 타이핑

JDK 7 이전의 바이트코드 명령어 집합에는 메서드 호출 명령어가 총 4개였다（invokevirtual, invokespecial, invokestatic, invokeinterface） <br>
그리고 이 명령어들의 첫번째 매개변수는 호출된 메서드의 심벌 참조인데, 메서드 심벌 참조는 컴파일타임에 생성된다. <br>
반면 동적 타입 언어에서는 호출 대상을 런타임에 결정할 수 있어야 한다.

### invokedynamic 명령어

동적 타입 언어를 더 잘 지원하기 위해 JDK 7에서 다섯 번째 메서드 호출용 바이트코드 명령어인 invokedynamic을 도입했다. <br>
기존 invoke* 명령어 4개를 활용한 메서드 해석 로직은 온전히 가상 머신 자체에 고정되어 있다. <br>
반면 invokedynamic과 메서드 핸들은 메서드 해석 책임을 가상 머신으로부터 특정한 사용자 코드로 옮기는 역할을 한다. <br>
메서드 핸들은 상위 수준 코드와 API로 구현되고 invokedynamic은 바이트코드와 클래스의 속성 및 상수 수준에서 구현되는 점이 다르다.

## 스택 기반 바이트코드 해석 및 실행 엔진

많은 자바 가상 머신 실행 엔진에서 자바 코드를 실행할 때 해석 실행과 컴파일 실행 중에서 선택할 수 있다. <br>
해석 실행은 인터프리터가 실행하는 걸 말하며, 컴파일 실행은 JIT 컴파일러를 써서 네이티브 코드로 변환해 실행하는 걸 말한다. <br>
이번 절에서는 바이트코드를 해석하고 실행할 때 자바 가상 머신의 실행 엔진이 어떻게 작동하는지 개념 모델을 기준으로 분석할 것이다.

### 해석 실행

해석을 하든 컴파일을 하든, 물리 머신이든 가상 머신이든, 기계가 마치 사람처럼 애플리케이션을 읽고 이해하고 실행하는 것은 불가능하다. <br>
대부분의 프로그램 코드가 물리 머신의 목적 코드나 가상 머신이 실행할 수 있는 명령어 집합으로 변환되기까지는 그림과 같은 단계를 거친다. <br>
오늘날 물리 머신, 자바 가상 머신, 기타 고수준 언어용 가상 머신은 그림과 같은 고전적인 컴파일 원칙에 따라 소스 코드의 어휘와 구문을 분석하여 추상 구문 트리로 변환한다. <br>
자바 언어에서 javac 컴파일러는 프로그램 코드의 어휘 분석, 구문 분석, 추상 구문 트리 생성, 나아가 구문 트리를 탐색해 일련의 바이트코드 명령어들을 생성하는과정까지 처리한다. <br>
이처럼 작업 대부분이 가상 머신 외부에서 수행되고 인터프리터는 가상 머신 내부에 있으므로 자바 프로그램 컴파일은 준독립적인 구현에 속한다.

<img width="694" alt="Image" src="https://github.com/user-attachments/assets/762fd572-f333-4c3e-b415-b4d2415bfec7" />

### 스택 기반 명령어 집합과 레지스터 기반 명령어 집합

javac 컴파일러가 출력하는 바이트코드 명령어 스트림은 기본적으로 스택 기반 명령어 집합 아키텍처를 따른다. <br>
즉, 바이트코드 명령어 스트림의 명령어 대부분은 메모리 주소 대신 피연산자 스택을 이용해 동작한다. <br>
또 다른 주류 아키텍처인 레지스터 기반 명령어 집합 아키텍처의 대표적인 예는 x86이다.

스택 기반 명령어 집합의 장점은 무엇일까? 가장 중요한 장점은 이식성일 것이다. <br>
레지스터는 하드웨어에서 직접 제공하는데, 하드웨어에 직접 의존하는 프로그램은 해당 하드웨어에 종속될 수 밖에 없기 때문이다. <br>
스택 기반 명령어 집합을 이용하면 사용자 프로그램은 하드웨어 레지스터를 직접 사용하지 않는다. <br>
그 대신 가상 머신이 자주 사용하는 데이터를 레지스터에 저장하여 최상의 성능을 내도록 노력한다. <br>
따라서 특정 하드웨어에 의존하지 않게 구현하기가 더 쉽다.

단점으로는 스택 기반 명령어 집합은 실행 속도가 상대적으로 느리다. <br>
주류 물리 머신이 모두 레지스터 기반 아키텍처이기 때문이다. <br>
해석 실행 모드에서 스택 기반 명령어 집합의 코드 각각은 더 간결할지라도 같은 기능을 완료하기 위해 필요한 명령어의 총개수가 레지스터 기반 아키텍처보다 많은 게 보통이다. <br>
데이터를 스택에 넣고 빼는 일 자체가 상당한 수의 명령어를 생성하기 때문이다. <br>
나아가 스택이 메모리에 구현되면 메모리 접근이 빈번하게 일어난다는 문제가 생긴다.
메모리는 프로세서 자체에 내장된 레지스터보다 훨씬 느리기 때문에 성능을 상당히 떨어뜨리는 요인으로 작용한다.














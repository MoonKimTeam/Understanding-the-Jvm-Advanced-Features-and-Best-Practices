# ch11. 백엔트 컴파일과 최적화

- 책에서 말하는 JIT 컴파일러는 핫스팟 가상 머신의 내장 컴파일러를 의미, 가상머신은 핫스팟 가상머신을 의미

## JIT 컴파일러

- 핫스팟, OpenJ9는 아주 자주 실행되는 메서드나 코드 블록(`핫스팟 코드`, `핫 코드`)이 발견되면,
- 해당 코드를 `네이티브 코드`로 컴파일하고 다양한 최적화를 적용해 실행 효율을 높임

### 인터프리터와 컴파일러

- 핫스팟과 OpenJ9는 인터프리터 컴파일러 함께 사용
- 인터프리터: 컴파일 없이 바로 실행 가능(빠른 시작), 메모리 절약
- 컴파일러: 시간이 지날수록 네이티브코드로 컴파일 -> 실행 효율 높임
- 핫스팟 가상 머신의 JIT 컴파일러에는 클라이언트 컴파일러(C1 컴파일러), 서버 컴파일러(C2 컴파일러) 존재
    - 세번째 컴파일러는 그랄 컴파일러
- 계층형 컴파일 모드 등장 전: 인터프리터가 단 하나의 컴파일러와 협력(C1 또는 C2)
- 이후: 자체 버전과 호스트 머신의 하드웨어 성능에 맞춰 실행 모드 자동 선택
- 모드(`-version` 매개변수로 확인 가능)
    - 혼합 모드(인터프리터 + 컴파일러)
    - 해석 모드(`-Xint` 매개 변수)
    - 컴파일 모드(`-Xcomp` 매개 변수)
- 바이트 코드를 네이티브로 컴파일 시 시간 걸림(최적화 많이 할수록 더)
- 최적화 위한 성능 모니터링도 해석과 실행 단계 속도에 영향
- 계층형 컴파일 기능 추가: 응답 속도와 운영 효율 사이 균형
    - 계층 0: 인터프리터가 프로그램 해석. 성능 모니터링 X
    - 계층 1: 클라이언트 컴파일러 사용하여 네이티브 코드로 컴파일. 성능 모니터링 X
    - 계층 2: 클라이언트 컴파일러 사용. 몇 가지 성능 모니터링 O
    - 계층 3: 클라이언트 컴파일러 사용. 모든 성능 모니터링 O
    - 계층 4: 서버 컴파일러 사용. 성능 모니터링 O. 공격적인 최적화 수행
    - 핫코드 여러 번 컴파일 될 수 있음

### 컴파일 대상과 촉발 조건

- 조건
    - 여러 번 호출 되는 메서드
    - 여러 번 실행되는 순환문의 본문
- 핫 스팟 탐지(핫 코드 여부 판단) 방식
    - 샘플 기반 핫스팟 코드 탐지: 스레드의 호출 스택 상단을 주기적으로 샘플링 (구현 쉬움)
    - 카운터 기반 핫스팟 코드 탐지: 메서드와 코드 블록에 대한 카운터 설정하고 카운팅 (정확, 엄격)
- 핫스팟 가상 머신: 메서드 호출 카운터와 백 에지(순환문 경계에서 순환문 처음으로 점프) 카운터

### 메서드 호출 카운터에 의한 JIT 컴파일러 촉발

- 기본 문턱값: 클라이언트 모드 1500회, 서버 모드 1만 회
- `-XX:CompileThreshold` 매개 변수로 직접 설정 가능
- 메서드 호출 시 컴파일 버전 있는지 확인 후 있으면 네이티브 코드, 없으면 인터프리터 실행
- 메서드 호출 카운터: 단위 시간당 호출 횟수를 계산
- 감쇠 메서드 호출: 단위 사간 동안 호출 횟수 미도달 시 카운터 값을 절반으로 줄임
    - `-XX:-UseCounterDecay`로 비활성화 가능
    - `-XX:-CounterHalfLifeTime`으로 반감기 초 단위 설정 가능

### 백 에지 카운터에 의한 JIT 컴파일 촉발

- 백 에지 카운터: 특정 순환문의 본문 코드 실행 횟수 계산
    - 목적: 온 스택 치환(OSR) 컴파일 촉발
    - 문턱값은 계산하면 13995(클라이언트 모드), 10700(서버 모드)
- 인터프리터는 백 에지 명령어 만나면 있는지 컴파일된 버전 유무 확인 -> 있으면 실행, 없으면 카운터 증가
- 문턱값 초과 시 OSR 컴파일 요청
- 백 에지 카운터 오버플로 -> 메서드 호출 카운터도 오버플로 -> 다음 호출시 표준 컴파일 진행

### 컴파일 과정

- 백그라운드에서 별도 스레드가 진행
    - `-XX:-BackgroundCompilation` 매개 변수로 비활성화 가능
    - 비활성화 상태에서는 컴파일 요청 스레드가 컴파일이 완료될 때까지 대기 후 네이티브 코드 실행

#### 클라이언트 컴파일러의 컴파일 과정

- 비교적 간단 3단계 컴파일러(전역 최적화 포기, 지역 최적화 집중)
    - 단계 1: 프런트엔드가 HIR 생성(타깃 독립적 중간 표현)
    - 단계 2: 백엔드가 HIR로부터 LIR 생성
    - 단계 3: 백엔드가 선형 스캔 레지스터 사용하여 LIR에 레지스터 할당 핍홀 최적화 수행 -> 네이티브 생성

#### 서버 컴파일러의 컴파일 과정

- 서버 측 성능 극대화하도록 설정된 컴파일러
- 죽은 코드 제거, 순환문 언롤링, 순환문 표현식 호이스팅, 공통 하위 표현 제거, 상수 전파, 기본 블록 재정렬 등 전통적 최적화 수행
- 범위 검사 제거, null 검사 제거 등 자바 언어에 특화된 최적화 수행
- 상대적으로 느리지만 전통적인 정적 최적화 컴파일러보다 훨씬 빠름
- 네이티브 코드 결과물 성능이 긴 컴파일 시간을 상쇄하고도 남음

### 실전: JIT 컴파일 결과 확인 및 분석

- 제대로 실습하려면 1장 설명대로 JDK 빌드 필요(FastDebug 모드 빌드 위해)

#### JIT 컴파일 결과 확인

-`-XX:+PrintCompilation` 매개변수 지정하면 JIT 컴파일러가 네이티브 코드로 컴파일한 메서드 이름 출력

- %는 온스택 치환 의미
- 여러번 컴파일 됨
    - 클라이언트 컴파일러는 간단한 최적화만 적용하여 속도가 빠름
    - 서버 컴파일러는 더 많은 최적화를 적용하는 만큼 더 느림
    - 우선 클라이언트 컴파일 수행, 백그라운드에서 서버 컴파일러 실행
    - 최적화 수행 이후에도 모니터링하다 추가 최적화 시도 가능
- `-XX:+PrintInlining`: 메서드 인라인 정보 출력
- `-XX:+PrintAssembly`: 컴파일된 메서드의 어셈블리 코드 출력
- `-XX:+UnlockDiagnosticVMOptions`: 진단 모드 실행
- `-XX:+PrintCFGToFile`(클라이언트용), `-XX:+PrintIdealGraphFile`(서버용): 네이티브 코드 생성 과정 추적
- 클라이언트 컴파일러용 CCV, 서버 컴파일러 용인 IGV로 분석 가능

#### JIT 컴파일 과정 분석

- IGV로 코드 생성과정 분석 -> 책 참조

## AOT 컴파일러

- JIT 컴파일러 등장 이후 머지않아 AOT 컴파일러 등장
- ART(안드로이드 런타임) 등장으로 기존 달빅 VM 찬밥 신세
- 안드로이드에서의 컴파일 혁신이 자바 세계에 충격을 줌

### AOT 컴파일의 장점과 단점

### AOT의 매력

- AOT 두 가지 형태
    - 실행 전 네이티브 코드로 컴파일
        - JIT 컴파일은 애플리케이션 실행 중에 뒤에서 컴퓨터 자원 소비(필연적)
        - 프로시저 간 분석이 가장 대표적인 예
            - 매우 오래 걸리는 계산 수행
        - 현재 모든 JVM은 프로시저간 분석 효과를 일부 흉내내는 식으로 수행
        - 프로그램 실행 전 컴파일 정적 수행 -> 시간 소모적인 최적화도 부담없이 수행 가능
            - 처음 실행 시 네이티브 이미지 만드느라 느려지지만, 전체 UX에 영향 적음
    - JIT 컴파일러가 런타임에 수행해야 하는 작업을 미리 수행 후 "캐시", 다음 번에 사용
        - 캐시 역할 극대화, 구동 시간 단축, 구동 후 최상의 성능 냄
        - OpenJDK 및 오라클 JDK 9의 jaotc 컴파일러
            - 그랄 컴파일러 기반
            - 구동 속도 높이고, 최고 성능 실행 소요 시간 단축
    - 아직 난제는 많지만 AOT 컴파일은 의심의 여지 없이 성능을 극한으로 끌어내는 수단

### JIT의 반격

- JIT이 AOT보다 나은 점
    - 성능 모니터링 기반 최적화
        - 인터프리터/컴파일러 실행 시 다양한 성능 모니터링 수집
    - 급진적 예측 최적화
        - AOT와 다르게 100% 정확하지 않더라도 모니터링 정보 기반으로 높은 확률로 정확한 판단 가능
        - "모로 가도 서울만 가면 그만" 가능
        - 가상 메서드 호출 시 인라인 최적화 수행
    - 링크 타임 최적화
        - 자바는 동적 링크 수행
        - JIT은 클래스가 런타임에 메모리에 로드된 다음 네이티브 컴파일 가능
        - AOT는 동적 링크 라이브러리와 프로그램 코드의 경계가 분명해서 최적화하기 어려움

### 실전: jaotc의 AOT 컴파일

- JDK 9에서 도입
- 구동 예열 시간 줄여 최대 성능 끌어냄
- but, 특정 하드웨어에서 특정 가상 머신 매개 변수 필요 -> 잘 이해하고 활용하는 개발자 적음
- JDK 16부터는 관련 코드와 도구를 그랄 VM으로 넘기고 제거
- 실습은 책 참조


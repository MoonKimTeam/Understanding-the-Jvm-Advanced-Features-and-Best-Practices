# 자바 기술 시스템 소개

오늘날 자바 기술 시스템에는 소프트웨어 개발자 수백만 명이 몸담고 있다. <br>
엄격한 구조를 갖춘 객체 지향 프로그래밍 언어란 점 외에도 자바에는 무시할 수 없는 장점이 많다.

- 하드웨어 플랫폼이라는 족쇄를 제거하여 "한 번 작성하면 어디서든 실행된다"라는 이상을 실현한다.
- 상당히 안전한 메모리 관리 시스템을 갖춘 덕에 메모리 누수 문제와 엉뚱한 메모리를 가리키는 문제 대부분을 피할 수 있다.
- 런타임에 핫 코드를 감지, 컴파일하고 최적화하여 자바 애플리케이션이 최상의 성능을 내도록 도와준다.
- 표준 API 자체가 풍부할 뿐 아니라 수많은 기업과 오픈 소스 커뮤니티 에서 제공하는 다양한 기능의 서드 파티 라이브러 리를 활용할 수 있다.

<br>


일반적으로 JVM 위에서 동작하는 코틀린, 클로저, 그루비 등의 프로그래밍 언어와 그 외 관련 프로그램들도 자바 기술 시스템에 속하는 것으로 본다. <br>
전통적으로 자바 기술 시스템은 다음 요소들을 포괄한다.

- 자바 프로그래밍 언어
- 자바 가상 머신 구현
- 클래스 파일 포맷
- 자바 클래스 라이브러리 API
- 다른 기업과 오픈 소스 커뮤니티에서 제공하는 서드 파티 클래스 라이브러리

**이 중 특히 자바 프로그래밍 언어, 자바 가상 머신, 자바 클래스 라이브러리를 묶어 JDK라고 한다.** <br>
JDK는 자바 프로그램 개발에 필요한 최소한의 환경이다. <br>
**또한 자바 SE API와 자바 가상 머신, 배포 기술까지를 묶어 JRE라고 한다.** <br>
JRE는 자바 프로그램을 실행할 수 있는 표준 환경을 제공한다.

<img width="721" alt="스크린샷 2024-12-21 오후 4 17 08" src="https://github.com/user-attachments/assets/f8200aff-0b08-42bb-967a-2a1d2382d9aa" />

## 자바의 과거와 현재

### 오라클의 품으로

2009년 2월 19일 코드명 돌핀인 JDK 7의 첫 번째 이정표 버전이 완성된다. <br>
JDK 7의 초기 기능 목록을 보면 다수의 중요한 개선 사항이 보인다.

- 람다식과 함수형 프로그래밍 지원
- 가상 머신 수준에서의 모듈화 지원
- 자바 언어는 정적 언어이지만 자바 가상 머신은 제 3의 동적 언어 지원
- 고성능 가비지 컬렉터 (G1)
- 자바 구문의 세부 사항 개선

### 모던 자바의 시작

2014년 3월 18일 원래 2013년 9월로 계획되었던 JDK 8이 마침내 출시된다. <br>
JDK 8에는 JDK 7을 목표로 계획했다가 완성하지 못한 기능이 다수 포함됐다. <br>

- 람다식 지원
- 나스혼 자바스크립트 엔진 내장
- 새로운 시간 및 날짜 API
- 핫스팟에서 영구 세대 완전 제거

### 기민하게

JDK 9 출시 후 오라클은 자바 연구 개발을 더 기민하게 진행하면서 출시도 지속적 배포 형태로 전환할 것이라고 발표했다. <br>
한 번에 너무 많은 기능을 추가하는 과정에서 발생하는 위험 요소를 줄이기 위함이었다.

<img width="794" alt="스크린샷 2024-12-21 오후 4 23 16" src="https://github.com/user-attachments/assets/3724146a-e0fa-4597-8770-3229db2bf04b" />

## 자바 기술의 미래

### 언어 독립

2018년 4월 오라클 연구소는 그랄VM이라는 새로운 기술을 발표했다. <br>
**어디서든 더 빠르게 실행한다**라는 구호를 보면 1995년에 자바가 탄생하며 내건 구호인 "한 번 작성하면 어 디서든 실행 된다"가 떠오른다. <br>
그랄VM은 핫스팟 가상 머신 위에 구축된 크로스 언어 풀 스택 가상 머신이다. <br>
자바, 코틀린, 스칼라, 그루비 같은 자바 가상 머신 언어들은 물론 LLVM 기반 컴파일러를 사용하는 C-C++, 러스트 같은 언어들, 그 외 자바스크립트, 루비, 파이썬, R, 웹어셈블리까지도 지원한다. <br>
그랄VM에서는 추가 비용 없이 이 언어들을 혼합해 사용할 수 있다.

그랄VM은 기본적으로 각종 언어의 소스 코드나 컴파일된 중간 형식을 인터프리터를 통해 그랄VM이 이해할 수 있는 중간 표현으로 변환하는 식으로 작동한다. <br>
**그랄VM은 진정한 의미에서 물리 머신에 대응하는 고수준 언어 가상 머신이다.** <br>
프로그래밍 언어마다 런타임 환경 성능이 제각각이라 어떤 언어는 성능이 상대적으로 많이 떨어지기도 한다. <br>
하지만 그랄VM은 입력된 중간 표현을 자동으로 최적화하고 런타임에 JIT 컴파일까지 해 주기 때문에 때로는 네이티브 컴파일러들보다 실행 성능이 나을 수 있다.

그랄VM은 자바 가상 머신으로 활용할 수 있다. 애초에 핫스팟을 기반으로 탄생했으며 자바 SE와 완벽하게 호환되기 때문이다. <br>
표준 핫스팟과의 차이는 주로 JIT 컴파일러에서 오며, 현재 실행 효율과 컴파일 품질 모두 표준 핫스팟보다 나은 것으로 평가된다.

### 차세대 JIT 컴파일러

서버용 제품처럼 장기간 운용되는 애플리케이션에서는 자주 실행되는 핫 코드를 탐지하여 네이티브 코드로 컴파일한다. <br>
이런 유형의 자바 애플리케이션은 JIT 컴파일러의 출력 품질이 실행 효율을 크게 좌우할 수밖에 없다. <br>
핫스팟 가상 머신은 기본적으로 JIT 컴파일러를 두 개 내장하고 있다. 하나는 컴파일 속도가 빠른 대신 최적화를 적게 하는 클라이언트 컴파일러（C1 컴파일러）이고, <br>
다른 하나는 컴파일 속도는 느리지만 더 많은 최적화를 적용하는 서버 컴파일러(C2 컴파일러) 다.

**JDK 10부터는 하나가 더 추가되었다. 바로 그랄 컴파일러다.** <br>
그랄 컴파일러는 C2 컴파일러를 대체할 목적으로 핫스팟에 도입되었다. <br>
그랄VM은 자바 언어로 작성되었다. 그리고 C2와 똑같은 고수준 중간 표현을 사용해서 C2의 이점을 수용하기 쉽다. <br>
컴파일된 코드의 출력 품질은 더 좋게 유지하면서 개발 효율과 확장성 측면에서는 C2와는 비교하기 어려울 만큼 훌륭하다.


### 네이티브를 향한 발걸음

장시간 실행할 필요가 없거나 크기가 작은 애플리케이션의 경우 자바로 개발하면 본질적인 단점이 몇 가지 있다. <br>
HelloWorld를 실행하려 해도 100MB가 넘는 JRE가 필요하다는 점도 있지만, 더 중요한 문제는 애플리케이션 아키텍처의 중심은 거대한 단일 아키텍처에서 작은 마이크로서비스 아키텍처로 빠르게 옮겨 가고 있다. 그런데 자바는 이 추세와 잘 맞지 않는다. <br>
마이크로서비스 아키텍처에서는 분할된 서비스 각각이 더 이상 수십에서 수백GB의 메모리를 쓸 일이 없다. <br>
고가용성 서비스 클러스터를 활용하면 단일 서비스를 24시간 중단 없이 실행하기 위해 노력할 이유가 줄어든다. <br>
하지만 자바는 구동 시간이 길고 최고 성능을 내기까지 예열이 필요하다.

최근 JDK에는 애플리케이션 클래스 데이터 공유(AppCDS)와 노옵(no-op) 가비지 컬렉터인 엡실론 등의 기술이 포함되었다. <br>
AppCDS는 로딩한 클래스 정보를 캐시해 두어 다음번 구동 시간을 줄이는 기술이다. <br>
더 급진적인 기술로는 애플리케이션을 실행하기 전에 네이티브 코드로 컴파일해 두는 AOT 컴파일이 있다. <br>
지금까지 자바 가상 머신은 애플리케이션을 우선 실행한 후 JIT 컴파일러를 써서 빈번하게 실행되는 로직을 네이티브 코드로 바꿔 실행했다. <br>
하지만 컴파일을 미리 해 두면 이러한 예열 과정을 건너뛰고 처음부터 네이티브 코드를 실행할 수 있다. 이 점이 AOT 컴파일의 최대 강점이다.

AOT 컴파일은 단점도 명확하다. "한 번 작성하면 어디서든 실행된다"라는 자바의 약속을 지킬 수 없다. 다시 말해 하드웨어와 운영 체제별로 따로 컴파일해 배포해야 한다. <br>
이러한 기대에 부응하고자 서브스트레이트 VM이 등장했다. <br>
그랄 VM의 한 요소인 서브스트레이트 VM은 사전 컴파일된 네이티브 코드를 핫스팟 가상 머신 없이 실행하는 기술로 독자적인 예외 처리, 스레드 관리, 메모리 관리, 자바 네이티브 인터페이스（이하 JNI） 접근 메커니즘 등을 갖춘 극히 작은 런타임 환경이다. <br>
서브스트레이트 VM은 메모리 사용량도 크게 줄였다.

### 언어 문법의 지속적인 개선

- 지역 변수 타입 추론 (var) 도입
- 람다식 매개 변수로 사용할 수 있도록 지역 변수 구문 개선
- switch 문을 표현식으로 사용할 수 있는 문법 추가
- + 없이 문자열 여 러 줄을 쉽게 표현할 수 있는 문법 추가
- 패턴 매칭 능력을 부여해 instanceof 연산자의 표현력 강화
- 데이터 전달용 불변 클래스인 레코드 타입 추가
- 자신을 확장하거나 구현할 수 있는 클래스와 인터페이스를 제한하는 봉인된 클래스와 봉인 인터페이스 타입 추가
- 레코드 클래스로부터 데이터를 가져올 때 패턴 매칭 제공
- switch 문 표현식의 패턴 매칭 능력 개선






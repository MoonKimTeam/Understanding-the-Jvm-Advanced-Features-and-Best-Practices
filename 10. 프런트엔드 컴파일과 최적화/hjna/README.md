# 프런트엔드 컴파일과 최적화

## 들어가며

자바 기술에서 흔히 사용하는 ‘컴파일타임’이라는 용어는 맥락에 따라 다르게 해석될 수 있다. 프런트엔드 컴파일러, 더 정확하게는 컴파일러의 프런트엔드는 .java 파일을 .class 파일로 변환하는 과정을 의미하며, 자바 가상 머신에서 JIT 컴파일러가 바이트코드를 기계어로 변환하는 과정 역시 컴파일에 해당된다. 또한 AOT 컴파일러를 사용하여 실행 파일 수준의 코드로 컴파일하는 방법도 존재한다.

프런트엔드 컴파일러에는 JDK의 javac나 이클립스 JDT의 ECJ가 포함되고, JIT 컴파일러는 핫스팟 가상 머신의 C1, C2 컴파일러와 같은 런타임 컴파일러가 있다. AOT 컴파일러에는 jaotc, 자바용 GNU 컴파일러인 GCJ, 혹은 예전의 JET 같은 컴파일러가 있다. 대부분의 자바 개발자는 컴파일러라고 하면 이 중에서 첫 번째 유형, 즉 프런트엔드 컴파일러를 떠올린다. 이 장에서는 ‘프런트엔드’ 컴파일러를 중심으로 설명한다. 따라서 ‘컴파일타임’이나 ‘컴파일러’라는 표현이 나오면 기본적으로 프런트엔드 컴파일러를 의미한다고 이해하면 된다.

프런트엔드 컴파일러와 관련된 최적화는 실행 효율과는 거의 관련이 없다. javac는 코드 실행 속도를 높이는 최적화를 수행하지 않으며, JDK 1.3 이후부터는 -O 옵션을 붙이더라도 실제 성능 차이가 없다. 이는 자바 가상 머신 설계가 성능 최적화를 런타임 컴파일러에 집중하도록 구성되어 있기 때문이다. 또한, javac로 생성되지 않는 클래스 파일들, 예를 들어 JRuby나 Groovy로 작성한 클래스 파일도 최적화 효과를 동일하게 누릴 수 있어야 하므로, 실행 효율을 고려한 최적화는 런타임에서 수행하는 것이 설계상 적절하다.

하지만 프런트엔드 컴파일러 역시 개발 단계에서 코드 간소화, 불필요한 코드 제거 등 일부 최적화를 수행할 수 있다. 실제로 javac는 이런 개발자 편의를 위해 클래스 내부 구조를 단순화하거나, 문법을 바이트코드 수준으로 변환하는 역할을 한다. 최신 자바 문법 중에는 컴파일러가 명시적 바이트코드 변환 없이 단순히 구문 해석만으로도 구현할 수 있는 기능이 많다.

### javac 컴파일러

JDK 5까지는 javac가 표준 Java SE API에 포함되지 않았고, 구현 코드는 tools.jar에 별도로 담겨 있었다. 따라서 javac를 프로그램에서 사용하려면 tools.jar 라이브러리가 클래스패스에 존재해야만 했다. 그러나 JDK 6부터는 컴파일러 API(JSR 199)가 도입되며 javac 컴파일러 구현 코드가 표준 자바 클래스 라이브러리로 편입되었다. 이후로는 javac의 소스 코드가 JDK 내의 공식 위치에 존재하게 되었으며, JDK 버전별로 소스 위치는 약간씩 다르다. JDK 6~8까지는 JDK_SRC_HOME/langtools/src/share/classes/com/sun/tools/javac, JDK 9에서는 JDK_SRC_HOME/langtools/src/jdk.compiler/share/classes/com/sun/tools/javac, JDK 10부터는 JDK_SRC_HOME/src/jdk.compiler/share/classes/com/sun/tools/javac에 위치한다. 이 절에서는 JDK 17을 기준으로 소스 코드 구조를 설명한다.

javac 컴파일러는 JDK 자체 표준 클래스 라이브러리와 JDK_SRC_HOME/src/jdk.compiler/share/classes/com/sun/tools/javac 경로 내 코드에 의존하고, 이 경로만으로도 컴파일이 가능하다. 이클립스에서 Compiler_javac 프로젝트를 만들고 해당 경로의 모든 파일을 src로 가져오면 된다. 그림 10-1은 이클립스에 소스를 가져오는 장면을 보여준다.

javac 소스 코드의 메인 클래스는 com.sun.tools.javac.Main이다. 이 클래스를 실행하면 자바 코드를 컴파일할 수 있으며, 아무런 인자를 주지 않으면 사용법을 안내하는 메시지만 출력된다. 인자는 명령행으로 넘겨야 하며, 이클립스에서는 Debug Configurations나 Run Configurations의 Arguments 탭에서 설정하면 된다.

컴파일 과정은 자바 소스 파일을 바이트코드로 변환하는 일련의 단계로 구성된다. javac의 컴파일 과정은 com.sun.tools.javac.main.JavaCompiler 클래스가 주도하며, 내부적으로는 compile() 메서드에서 다음과 같은 처리 단계를 거친다.

첫 번째 단계는 플러그인 애너테이션 처리기를 초기화하는 준비 단계이고, 두 번째 단계는 구문 분석 및 심벌 테이블 채우기이다. 이 단계에서는 소스 코드를 토큰화하고 추상 구문 트리를 구성하며, 심벌 주소와 정보를 담은 심벌 테이블을 생성한다. 세 번째 단계는 애너테이션 처리기로 애너테이션을 처리하며, 네 번째 단계는 의미 분석과 바이트코드 생성을 수행한다. 이 과정에서는 문법의 정적 정보 확인, 프로그램의 동적 실행 과정 확인, 단순화된 문법 복원, 바이트코드 변환 등이 순차적으로 수행된다. 만약 새로운 심벌이 생성되면 다시 앞 단계로 돌아가 구문을 분석하고 심벌 테이블을 채우는 순환 구조를 갖는다.

### 구문 분석과 심벌 테이블 채우기

자바의 컴파일 과정에서 중요한 단계인 어휘 분석과 구문 분석은 parseFiles() 메서드에서 처리된다. 어휘 분석은 소스 코드의 문자 스트림을 토큰이라는 작은 단위로 변환하는 과정이다. 이는 키워드, 변수 이름, 리터럴, 연산자 등으로 구성되며, 예를 들어 int a = b + 2라는 코드는 int, a, =, b, +, 2의 총 6개의 토큰으로 구성된다. 자바 컴파일러에서 이 과정을 담당하는 클래스는 com.sun.tools.javac.parser.Scanner이다.

이어서 수행되는 구문 분석은 이러한 토큰들을 기반으로 프로그램의 문법 구조를 분석하고, 추상 구문 트리(AST: Abstract Syntax Tree)를 구성하는 과정이다. 이 구문 트리는 코드의 구조를 계층적으로 표현하며, 각 노드는 패키지, 타입, 한정자, 연산자, 인터페이스, 반환값 등 다양한 구성 요소를 나타낸다. 실제 코드에서 구문 분석을 담당하는 클래스는 com.sun.tools.javac.parser.Parser이며, 생성된 구문 트리는 com.sun.tools.javac.tree.JCTree 클래스 구조로 표현된다. 이클립스의 ASTView 플러그인을 통해 이러한 추상 구문 트리를 시각적으로 확인할 수 있으며, 코드 분석의 직관적인 이해를 돕는다.

구문 트리가 완성되면 이후의 컴파일 과정에서는 더 이상 원래의 문자 스트림을 사용하지 않고 구문 트리만을 활용하게 된다. 이처럼 분석이 완료된 구조 위에서 다음 단계인 심벌 테이블 채우기가 수행된다. enterTrees() 메서드가 이 작업을 담당하며, 이는 단계 1.2에 해당한다. 심벌 테이블은 변수명, 타입, 메서드 정보 등 이름과 관련된 데이터를 해시 테이블이나 트리, 스택 형태로 저장하는 구조이다. 의미 분석 단계나 코드 생성 시 심벌 테이블에 등록된 정보를 참조하게 되며, 예를 들어 변수의 유효성 확인이나 원래 선언 위치 탐색 등에 사용된다.

심벌 테이블의 구현 방식은 구현체마다 다르지만, 핵심은 키-값 구조의 테이블을 통해 각 컴파일 단위의 이름 정보를 정리하여 추상 구문 트리의 상위 노드와 연결된다는 점이다. 이 과정을 담당하는 클래스는 com.sun.tools.javac.comp.Enter이며, 각 단위에 대한 최상위 노드 목록과 package-info.java 파일(존재하는 경우)까지 포함하는 심벌 정보가 생성된다. 이와 같이 어휘 분석에서 구문 트리 구성, 그리고 심벌 테이블 채우기까지 일련의 과정은 컴파일러의 초반 분석 단계로서, 이후의 의미 분석과 바이트코드 생성의 기반이 된다.

### 애너테이션 처리

자바 언어는 JDK 5부터 애너테이션을 지원하기 시작했다. 애너테이션은 원래 일반적인 자바 코드와 동일한 방식으로 설계되었지만 프로그램 실행 중에만 동작하는 기능을 담당했다. 그러나 JDK 6부터는 ‘플러그인할 수 있는 애너테이션 처리 API’라는 표준이 도입되었다. 이 API는 일부 애너테이션을 컴파일타임에 미리 처리할 수 있게 하여, 프런트엔드 컴파일러의 동작에 직접 영향을 미칠 수 있다. 플러그인 애너테이션 처리기는 이 과정에서 추상 구문 트리의 임의 요소를 읽고 수정하거나 새롭게 추가할 수 있기 때문에 컴파일러용 플러그인이라고도 불린다. 이러한 플러그인이 애너테이션 처리 중 구문 트리를 수정하면 컴파일러는 다시 ‘구문 분석 및 심벌 테이블 채우기’ 단계로 되돌아가야 한다. 플러그인에 의한 구문 트리 수정이 멈출 때까지 이 과정을 반복하는데, 이 반복을 ‘라운드(round)’라고 부른다. 이는 그림 10-4에서의 역할상 화살표에 해당한다.

컴파일러의 애너테이션 처리 API를 이용하면 개발자의 코드가 컴파일러 동작에 영향을 미칠 수 있다. 구문 트리의 모든 요소뿐만 아니라 코드 주석에도 접근할 수 있으며, 이 모든 것을 플러그인 애너테이션 처리기로 제어할 수 있다. 이러한 기능은 매우 다양하게 활용될 수 있고, 개발자의 창의력에 따라 전통적으로 수동으로 수행되던 많은 작업을 자동화할 수 있다. 예를 들어, Lombok은 이 API를 이용하여 게터/세터 메서드 생성, null 확인, 예외 처리용 테이블 생성, equals() 및 hashCode() 메서드 자동 생성 등의 작업을 수행하여 코드의 보일러플레이트를 줄이고 개발자의 수고를 덜어준다.

플러그인 애너테이션 처리기를 사용하는 방법은 이번 장 말미에 간단한 실습을 통해 확인할 수 있다. javac 소스 코드에서 플러그인 애너테이션 처리기는 initProcessAnnotations() 메서드에서 초기화되며, 그림 10-5의 단계 0에 해당한다. 실행은 processAnnotations()가 담당하며 이는 단계 2에 해당한다. 이 메서드는 새 애너테이션 처리기가 있는지 확인하고, 존재할 경우 com.sun.tools.javac.processing.JavacProcessingEnvironment 클래스의 doProcessing() 메서드를 호출한다. 이 메서드는 새로운 JavaCompiler 객체를 생성하여 이후의 컴파일 단계를 계속 수행하게 한다.

### 의미 분석과 바이트코드 생성

의미 분석은 구문 분석 결과로 얻어진 추상 구문 트리를 기반으로 프로그램 코드가 구조적으로 올바르게 작성되었는지를 점검하는 작업이다. 추상 구문 트리는 코드의 구조는 잘 표현하지만 의미 체계가 논리적인지까지는 보장하지 못하기 때문에, 의미 분석의 핵심 목적은 타입 검사, 제어 흐름 검사, 데이터 흐름 검사 등을 통해 구조적 타당성을 검증하는 것이다. 예를 들어 변수 타입에 맞는 연산인지, 선언된 변수만 사용하는지 등을 확인하게 된다. 예시 코드에서 int d = a + c;는 의미적으로 문제없지만, int d = b + c;나 char d = a + c;는 자바 언어 규칙에 맞지 않아 컴파일되지 않는다. 통합 개발 환경에서는 이러한 오류를 빨간 밑줄로 미리 경고해주는데, 이 역시 의미 분석 단계에서 발견된 문제이다.

특성 검사는 의미 분석의 첫 번째 단계로, 변수의 선언 여부, 타입 일치 여부 등을 확인하며, 상수 접기(constant folding)라는 최적화도 수행된다. 예를 들어 int a = 1 + 2;는 컴파일 시점에 3으로 계산되어 저장되며, 실행 시 연산을 생략할 수 있다. 이 작업은 com.sun.tools.javac.comp.Attr와 Check 클래스가 담당한다.

다음은 데이터 흐름 분석과 제어 흐름 분석이다. 이 단계에서는 변수의 정의와 사용 여부, 코드 블록의 실행 경로 등이 올바른지 점검한다. 예를 들어 final 변수는 반드시 초기화되어야 하는데, 이를 위반하면 컴파일 에러가 발생한다. 또한 메서드 내 모든 실행 경로에서 return 문이 존재하는지, 초기화되지 않은 변수를 사용하는 경우는 없는지 등을 확인한다. 이 작업은 com.sun.tools.javac.comp.Flow 클래스가 수행한다.

편의 문법 제거는 의미 분석 단계의 마지막으로, 자바 문법 중 런타임에 직접 사용되지 않는 코드를 변환하여 처리한다. 예를 들어 지역 클래스, 열거형, 반복자, 익명 클래스, 오토박싱 등이 이에 해당하며, 이를 변환하는 desugar 작업은 com.sun.tools.javac.comp.TransTypes와 Lower 클래스가 담당한다. 이 과정을 통해 자바 문법의 다양한 표현을 바이트코드로 변환할 수 있는 형태로 정리한다.

의미 분석이 끝나면 바이트코드 생성 단계로 진입한다. 이 단계에서는 구문 트리에서 인스턴스 생성자 <init>()와 클래스 생성자 <clinit>()를 구분하여 생성하며, 이는 기존에 명시되지 않았더라도 컴파일러가 기본적으로 추가한다. 생성자는 명령 블록을 만들고, 인스턴스 변수 초기화, 부모 클래스 생성자 호출 등을 자동으로 처리하며, 이 작업은 Gen::normalizeDefs() 메서드가 수행한다.

또한 최적화된 코드 생성도 수행된다. 예를 들어 문자열 결합 코드인 + 연산자는 StringBuffer 또는 StringBuilder의 append() 메서드 호출로 변환된다. 최종적으로 바이트코드 생성에 필요한 모든 정보가 채워진 후, 이 정보는 com.sun.tools.javac.jvm.ClassWriter 클래스에 전달되어 writeClass() 메서드에서 .class 파일로 출력된다. 이 과정이 바로 자바 컴파일 과정의 최종 단계이다.

## 자바 편의 문법의 재미난 점

### 제네릭

제네릭의 본질은 매개 변수화된 타입 또는 매개 변수화된 다형성이라 할 수 있다. 달리 표현하면 특수한 매개 변수를 사용하여 작업 대상의 데이터 타입을 지정할 수 있게 하는 것이다. 클래스, 인터페이스, 메서드를 생성할 때 매개 변수 타입을 이용해 제네릭 클래스, 제네릭 인터페이스, 제네릭 메서드로 만들 수 있다. 제네릭을 이용하면 개발자가 데이터 타입에 구애받지 않는 알고리즘을 작성할 수 있어서 프로그래밍 언어의 타입 시스템과 추상화 능력이 크게 향상된다.

2004년은 JDK 5와 C# 2.0이 발표된 해다. 두 언어 모두에 중요한 버전 업그레이드였는데, 우연히 일치로 제네릭이 추가되었다. 그런데 제네릭을 구현하는 방식에서는 매우 다른 길을 택했다. 자바와 C#은 많은 면에서 서로 경쟁하는 관계였고, 그래서 같은 해에 같은 기능을 다른 방식으로 구현해 낸 탓에 수많은 비교 분석과 논쟁이 이루어졌다. 결론은 ‘자바의 제네릭은 C#보다 사용하기 어렵다’이며, 오늘날까지도 많은 이에게 아쉬움을 주고 있다. 이 책은 이러한 인식을 곧이곧대로 시도하지 않을 것이다. 오히려 자바 제네릭의 단점을 드러내는 예도 준비했다. 하지만 자바의 제네릭 메커니즘과 역사를 알고 나면 언어 자체의 발전 정도나 설계자의 수준이 C#보다 못해서는 아님을 이해하게 될 것이다. 당시 자바 언어가 처한 상황을 심문 고려하여 선택한 절충안일 뿐이다.

#### 자바와 C#의 제네릭

자바가 선택한 제네릭 구현 방식은 타입 소거 제네릭이며, 이는 컴파일 시점 이후 타입 정보가 사라지는 구조이다. 반면, C#은 구체화된 제네릭을 선택하여 런타임까지 타입 정보가 남아 있다. 따라서 C#에서는 List<int>와 List<string>이 완전히 다른 타입으로 간주되어, 가상 메서드 테이블과 타입 데이터가 각각 독립적으로 존재한다. 반면 자바에서는 소스 코드 상에만 제네릭 정보가 존재하고, 컴파일된 바이트코드에서는 원시 타입(raw type)으로 대체된다. 예를 들어 ArrayList<Integer>와 ArrayList<String>은 자바에서 동일한 타입으로 처리된다. 이러한 구조는 타입 소거(type erasure)라는 이름에서 알 수 있듯 타입 정보가 제거되는 방식으로, 런타임에 타입 검사를 수행하는 것이 불가능하다.

자바 제네릭의 이러한 특징은 몇 가지 제약을 동반한다. 예를 들어 인스턴스 생성, 배열 생성, 타입 비교 등의 연산에 제네릭 타입 매개변수를 사용할 수 없다. 이러한 제약은 코드의 단계에서 오류를 발생시키며, C# 개발자 입장에서는 문제를 찾기 어렵게 느껴질 수 있다. 이는 자바 제네릭이 컴파일러만을 통해 지원되기 때문이다. 반면 C#은 런타임까지 타입 정보를 보존하므로, 실행 성능 향상과 다양한 컨테이너 기능 구현이 더 자유롭다. 대표적인 예로 자바에서는 타입마다 별도로 클래스를 구현하거나, 형변환 코드를 반복적으로 작성해야 하지만, C#에서는 제네릭 컨테이너가 이를 자동으로 처리한다.

자바가 이러한 방식을 선택한 이유는 자바 가상 머신이 설계된 철학과 성능 고려 때문이다. 자바의 제네릭은 javac 컴파일러가 전적으로 책임지고 있으며, 바이트코드나 JVM은 이를 인식하지 않는다. 이는 바이트코드의 크기를 줄이고, 이전 버전의 JVM과 호환성을 유지하기 위함이다. 결국 자바의 타입 소거 제네릭과 C#의 구체화된 제네릭은 각각 당시의 언어 설계 철학과 환경에 따라 최적의 결정을 내린 결과이며, 한 쪽이 절대적으로 우월하다고 말할 수는 없다. 자바의 제네릭은 단점이 없지 않지만, 그 제약을 이해하고 활용하면 충분히 실용적인 기능을 제공하며, 성능과 호환성 측면에서 이점을 가진다.

#### 제네릭의 역사적 배경

제네릭이라는 아이디어는 C++의 템플릿 기능과 함께 시작되었으며, 자바 역시 1996년부터 이를 도입하려는 시도를 해왔다. 마르틴 오더스키는 함수형 프로그래밍을 지향하며 모든 기능을 언어에 넣으려 하지 않았고, 자바가 출시되기 1년 전부터 함수형 프로그래밍, 고차 함수, 패턴 매칭 등과 함께 제네릭 기능을 실험하던 피짜 언어(Fizza)를 만들었다. 이후 자바 개발팀은 피짜의 제네릭 기능에 주목하였고, 마르틴과 함께 ‘제네릭 자바’ 프로젝트를 시작했으며 이는 JDK 5에 제네릭이 도입되는 결과로 이어졌다. 하지만 피짜는 타입 소거 방식을 사용하지 않았고, 자바는 결과적으로 C#과 달리 타입 소거 방식을 택하게 된다.

자바의 제네릭 설계에서 가장 중요하게 고려된 요소는 ‘바이너리 하위 호환성’이었다. 이는 JDK 1.2에서 컴파일된 클래스 파일이 JDK 21 이상에서도 문제없이 실행되어야 한다는 명세적 요구사항이다. 따라서 자바는 제네릭 도입 이후에도 이전에 컴파일된 코드와의 호환성을 보장해야 했고, 이를 위해 제네릭 정보는 컴파일 시점에만 존재하며 바이트코드에서는 원시 타입으로 지워지는 타입 소거 방식이 채택되었다. 이런 설계 덕분에 다음과 같은 코드가 여전히 문제없이 컴파일되고 실행된다. 예를 들어 Object[] array = new String[10]; array[0] = 10; 와 같은 코드는 제네릭이 없던 시절의 코드로도 문제없이 실행될 수 있다.

제네릭을 도입하면서 자바는 새로운 선택의 기로에 놓였다. 첫 번째 방식은 기존 컨테이너 타입 중 일부는 그대로 두고 제네릭 버전을 따로 추가하는 방식이며, 두 번째는 기존 타입을 모두 제네릭 버전으로 대체하는 방식이다. C#은 두 번째 방식을 택했다. System.Collections와 같은 기존 컨테이너는 유지하면서, System.Collections.Generic이라는 이름 아래 새로운 제네릭 컨테이너들을 추가하였다. 자바는 반대로 첫 번째 방식을 택했다. 이는 이미 Vector와 ArrayList, Hashtable과 HashMap 같은 유사 기능을 하는 클래스들이 공존하고 있는 상황에서, 제네릭 버전을 추가할 경우 API가 중복되고 혼란을 일으킬 수 있다는 우려 때문이었다. 또한 당시 자바는 C#에 비해 더 많은 코드베이스와 레거시를 갖고 있었기 때문에 보수적인 선택이 더 현실적이었다.

자바가 타입 소거 방식을 택한 이유는 JVM의 명세와도 깊은 관련이 있다. 기존 JVM은 런타임에 타입 파라미터를 유지할 수 있는 구조가 아니었고, 이를 변경하기 위해서는 JVM 전체를 다시 설계해야 하는 부담이 있었다. 이런 이유로 자바는 기존 JVM 위에서도 제네릭을 구현할 수 있도록 타입 소거 방식을 택한 것이다. 이 방식은 런타임에는 실제 타입 정보를 유지하지 않기 때문에, 제네릭 타입으로 객체를 생성하거나 instanceof로 타입 비교를 하는 등의 문법 제약이 생기게 된다.

결론적으로 자바는 기존 코드와의 호환성과 JVM 명세라는 현실적인 제약 속에서 타입 소거 방식의 제네릭을 도입하게 되었고, 이는 C#의 구체화된 제네릭과는 대조되는 특징이다. 제네릭의 도입과정은 단순히 언어의 문법적 변화가 아니라 당시 자바가 처한 기술적 상황과 철학적 판단이 반영된 결과이며, 각 언어의 선택은 단순한 우열의 문제가 아닌 상황에 맞는 현실적 대응이었다고 볼 수 있다.

#### 타입 소거

자바 제네릭에서 타입 소거가 어떻게 구현되는지를 설명하기 위해 ArrayList를 예로 들 수 있다. 자바는 제네릭을 도입할 때 기존 타입들을 제네릭화해야 했기 때문에, 기존의 ArrayList와 같은 타입에 대해 제네릭이 필요해진 이후에는 ArrayList<T>라는 형태로 바뀌었다. 이때 기존 코드에서 사용된 ArrayList는 제네릭 버전에서도 동일하게 작동해야 했기 때문에 하위 호환성을 보장해야 했다. 예를 들어 ArrayList<Integer>와 ArrayList<String>은 모두 자동으로 ArrayList라는 원시 타입으로 컴파일되어야 한다. 그러나 이때 형 변환이 안전하게 이뤄지지 않는 문제가 발생할 수 있다. 이러한 상황에서 자바는 모든 제네릭 인스턴스의 공통 상위 타입을 “원시 타입”이라 정의하며, 제네릭 타입이 컴파일 단계에서 원시 타입으로 사라지는 방식을 타입 소거(type erasure)라고 한다.

타입 소거의 구현 방식은 두 가지다. 하나는 런타임에 자바 가상 머신이 자동으로 제네릭 타입을 생성하는 방식이고, 다른 하나는 컴파일타임에 제네릭 타입을 원시 타입으로 변환한 후에 필요한 형 변환 코드를 적절히 삽입하여 처리하는 방식이다. 자바는 후자의 방식을 택했으며, 이를 통해 컴파일된 바이트코드에는 제네릭 타입에 대한 정보가 남지 않게 된다. 이 방식을 확인하기 위해 제네릭을 사용하는 코드와 사용하지 않는 코드를 디컴파일해 보면 차이를 확인할 수 있다. 제네릭을 사용할 경우 컴파일러는 형 변환 코드를 자동으로 삽입해 안전성을 확보해준다. 반면 제네릭을 사용하지 않으면 형 변환은 개발자의 책임으로 남는다.

자바의 타입 소거 방식은 타입 변수의 형변환을 자동 삽입하며, 런타임에는 모든 제네릭 인스턴스가 동일한 원시 타입으로 처리되기 때문에 ArrayList<Integer>와 ArrayList<String>은 동일한 타입으로 간주되어 오버로딩이 불가능하다. 이런 이유로 제네릭 클래스에서 오버로딩을 하면 예상과 다른 결과가 발생할 수 있다. 또한, 제네릭 타입의 매개변수를 사용하는 메서드에서 런타임 시 정확한 타입 정보를 얻을 수 없기 때문에, 배열 생성과 같은 연산에서 추가적인 타입 매개변수가 필요하다. 예를 들어 T[] array = (T[]) new Object[size];와 같은 코드가 등장하게 되는 것이다.

자바 가상 머신 명세는 이러한 제네릭 타입 정보의 손실 문제를 해결하기 위해 JDK 5부터 새로운 속성인 Signature와 LocalVariableTypeTable을 도입했다. Signature는 메서드의 시그니처 정보를 바이트코드 수준에서 저장하는 역할을 하며, 매개변수 타입이 기본 타입이 아닌 제네릭 타입인 경우까지 포함한다. 이 속성을 통해 리플렉션을 사용한 경우에도 제네릭 정보에 접근할 수 있다. JDK 5 이상부터는 클래스 파일이 Signature 정보를 포함하고 있어, 가상 머신이 올바르게 인식할 수 있도록 되어 있다.

정리하면, 자바의 제네릭은 타입 소거 방식으로 구현되어 런타임에 타입 정보가 존재하지 않으며, 컴파일 시점에 모든 제네릭 타입이 원시 타입으로 치환된다. 이로 인해 오버로딩 제한, 형변환 삽입, 배열 생성 제약 등의 단점이 발생하지만, 반대로 라이브러리 호환성, 바이너리 하위 호환성과 같은 장점을 제공한다. 이러한 구조는 메타데이터 기반의 리플렉션을 통해 어느 정도 극복 가능하며, 자바의 타입 소거 설계는 당시의 상황과 제약을 고려해 내린 실용적인 선택이었다고 평가할 수 있다.

#### 값 타입과 앞으로의 제네릭

자바 제네릭이 등장한 지 10년이 지난 2014년, 오라클은 자바 언어의 여러 결함 중 특히 제네릭의 결합 문제를 개선하기 위한 ‘발할라(Valhalla)’ 프로젝트를 시작하였다. 이 프로젝트는 원래 JDK 10을 목표로 했지만, 현재는 JDK 21에 일부 기능이 포함되었고, varHandle 등의 일부 목표는 성공적으로 릴리스되었다. 다만 JDK 21에 구현된 내용은 미리 보기(preview) 상태이므로, 추후 변경될 수 있음을 염두에 두어야 한다. 발할라 프로젝트는 원래 모델 1에서 모델 3까지 세 가지 새로운 제네릭 구현 방식을 고려했으며, 새로운 제네릭 설계에서는 제네릭 타입을 인스턴스화하거나 혹은 기존 방식인 타입 소거 방식을 유지할 수 있도록 설계되었다. 또한, 제네릭을 완전히 새로운 방식으로 구현하면서도 기존 바이트코드와의 호환성 확보를 매우 중요하게 고려하였다.

타입 소거 방식을 유지하면서도 매개 변수화된 타입 정보를 완전히 제거하지 않을 수도 있는 방식이 선택될 수 있으며, 경우에 따라 클래스 파일에 이 정보를 명시하여 컴파일러가 활용하게 할 수도 있다. 또한 컴파일러가 소거될 타입을 명시적으로 선택하거나, 제네릭을 다른 방식으로 구현하더라도 향후 자바는 값 타입을 언어 차원에서 지원하는 것이 중요한 과제로 떠오르고 있다. 값 타입은 C#의 ValueType과 유사한 개념으로, 자바에서 자주 지적되는 성능 이슈의 중심에 있다. 자바에는 C#과 달리 기본 데이터 타입 이외의 구조체 타입이 존재하지 않으며, C#에서는 int, boolean, double 등의 타입이 Int32, Boolean, Double과 같은 프리미티브 구조체로 정의된다. 이 구조체는 메서드와 속성을 가질 수 있으면서도 힙이 아닌 스택에 할당되어 성능이 뛰어나고, 할당 및 해제가 자동으로 이루어진다.

자바의 경우, 이러한 구조체가 없기 때문에 기본 타입은 객체로 자동 박싱/언박싱되며, 이는 성능 저하를 유발한다. 이를 보완하기 위해 발할라 프로젝트는 자바에 값 타입을 도입하고자 하며, value와 primitive라는 새로운 키워드를 계획하고 있다. value class는 클래스를 정의할 때 클래스의 식별성(identity)을 갖지 않는 값 타입을 나타내며, primitive class는 더 나아가 null이 될 수 없는 클래스를 정의할 수 있도록 한다. 이는 자바의 기존 객체 모델과는 전혀 다른 방향의 진화이며, 일반적인 힙 기반 객체 대신 성능이 중요한 영역에서 값 타입을 도입하여 가비지 컬렉터의 부담을 줄이는 데도 크게 기여할 수 있다. 이처럼 발할라 프로젝트는 기존 자바의 한계를 뛰어넘는 진보된 타입 시스템을 설계하고 있으며, 향후 자바 제네릭과 타입 시스템의 구조적 변화를 예고하고 있다.

### 오토박싱, 오토언박싱, 개선된 for 문

오토박싱, 오토언박싱, 그리고 개선된 for 문은 기술적으로는 모두 자바의 ‘편의 문법’에 해당한다. 이들은 제네릭처럼 구현 복잡성이나 타입 시스템에 대한 깊은 이해를 요하는 기능은 아니지만, 자바 개발에서 매우 자주 사용되는 문법이므로 하나의 절로 따로 설명된다. 먼저 편의 문법이 적용된 간단한 코드를 살펴보면, List<Integer> list = Arrays.asList(1, 2, 3, 4);와 같은 제네릭 선언, for (int i : list)와 같은 개선된 for 문, 그리고 기본 타입과 래퍼 타입 간의 자동 변환을 보여주는 오토박싱/언박싱이 포함되어 있다. 이처럼 짧은 코드 안에 제네릭, 오토박싱, 오토언박싱, 개선된 for 문, 가변 길이 매개변수 등 총 다섯 가지 편의 문법이 함께 사용되었다.

이 코드를 컴파일하면 실제로는 훨씬 더 복잡한 형태로 변환된다. Arrays.asList는 내부적으로 new Integer[]{} 배열을 생성하며 Integer.valueOf()로 각각의 숫자 값을 감싸고, 개선된 for 문은 Iterator를 통해 반복하는 구조로 변환된다. 또한 각 반복문 내부에서는 언박싱이 일어나 intValue() 메서드를 호출하게 된다. 이는 개발자 입장에서는 간단한 문법이지만, 컴파일러가 상당한 수준의 변환을 수행하고 있음을 보여준다. 개선된 for 문에서 반복 대상이 되기 위해서는 Iterable 인터페이스를 구현해야 하며, 이는 과거에는 배열을 기반으로 유사한 반복 처리를 구현하던 방식에서 진일보한 것이다.

그러나 이런 편의 문법들은 간단해 보이지만 사용 시 주의가 필요하다. 특히 오토박싱은 종종 실수를 유발할 수 있다. 예를 들어 Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321;와 같은 코드에서 System.out.println(c == d);는 true를 반환하지만, System.out.println(e == f);는 false를 반환한다. 이는 자바가 -128부터 127까지의 Integer는 내부적으로 캐싱하고 같은 객체를 재사용하지만, 그 외의 값은 새로 인스턴스를 생성하기 때문이다. 따라서 == 연산은 객체의 레퍼런스를 비교하므로, 값이 같아도 false가 될 수 있다. 또 Long g = 3L; System.out.println(g == (a + b));는 true이지만, System.out.println(g.equals(a + b));는 false가 된다. 이는 산술 연산에서는 오토언박싱이 발생해 기본형끼리 비교가 되지만, equals()는 타입이 정확히 일치해야 true를 반환하기 때문이다.

이러한 특성은 특히 실무에서 디버깅을 어렵게 만들 수 있으므로, 오토박싱/언박싱을 무분별하게 사용하는 것은 피해야 한다. 래퍼 클래스의 == 연산이 산술 연산과 만나지 않는다는 점, equals() 메서드가 내부적으로 언박싱을 하지 않는다는 점은 실수의 주요 원인이 될 수 있다. 따라서 이런 편의 문법들은 단순한 문법적 설탕(syntactic sugar)처럼 보일 수 있지만, 언어의 내부 동작을 이해하고 있어야만 안전하게 사용할 수 있다.

### 조건부 컴파일

C, C++의 전처리 지시어인 #ifdef처럼 많은 프로그래밍 언어에서는 컴파일을 조건부로 수행하는 방법을 제공한다. C, C++에서는 전처리기(preprocessor)가 컴파일 초기 단계에서 코드의 의존성을 해결하는 역할을 수행하며, #include 같은 명령을 처리한다. 반면 자바 언어는 전처리기를 사용하지 않는다. 자바 컴파일러는 자바 파일들을 하나씩 따로 처리하지 않고, 컴파일 단위 전체를 포함하는 구문 트리를 만들어 최상위 노드부터 하나씩 컴파일을 진행한다. 이런 방식은 각 파일이 서로에게 심볼 정보를 제공할 수 있게 해주지만, 전처리기 없이 조건부 컴파일이 가능한지에 대한 의문이 생길 수 있다.

자바에서도 조건부 컴파일은 가능하다. 조건문에 상수를 넣으면 특정 블록만 컴파일되도록 할 수 있다. 예를 들어 if (true) 조건문을 사용하면 해당 블록만 컴파일되고, else 블록은 바이트코드에서 제거된다. 이러한 방식은 상수를 조건에 사용할 때만 적용되며, 상수가 아닌 다른 조건식과 결합되면 제어 흐름 분석 단계에서 오류가 발생해 컴파일이 거부된다. 예를 들어 while (false) 문을 포함한 코드는 Unreachable Code 오류로 컴파일되지 않는다.

자바 언어의 조건부 컴파일 구현은 if 문을 이용하는 편의 문법에 해당하며, 컴파일러가 불가능한 조건을 미리 판단하고 포함시키지 않도록 코드 블록을 제거하는 방식으로 동작한다. 이러한 편의 문법 제거 작업은 com.sun.tools.javac.comp.Lower 클래스에서 수행된다. 단, 자바의 조건부 컴파일은 if 문을 이용한 문장 단위 수준에서만 가능하며, 클래스의 구조 자체를 바꾸는 것은 불가능하다.

이와 함께 설명한 제네릭, 오토박싱/언박싱, 개선된 for 문, 가변 길이 매개 변수, 조건부 컴파일 외에도 자바에는 다양한 편의 문법이 존재한다. 예를 들어 내부 클래스, 열거형, assert 문, 숫자 리터럴, switch 문에서의 문자열 지원, try 문에서 리소스 정의 및 닫기, 람다식, 테스트 블록 역시 모두 편의 문법에 해당한다. 자바 소스 코드를 컴파일한 후 디컴파일하여 차이를 비교하고 추적해 보면 이러한 편의 문법이 어떤 식으로 바이트코드에 반영되는지 확인할 수 있다.
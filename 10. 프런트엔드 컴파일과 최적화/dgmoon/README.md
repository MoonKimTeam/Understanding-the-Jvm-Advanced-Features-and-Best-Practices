# ch10. 프런트엔드 컴파일과 최적화

- 자바에서의 `컴파일`
    - 프런트엔드 컴파일러: JDK의 javac, 이클립스 JDR의 증분 컴파일러(ECJ)
    - JIT 컴파일러: 핫스팟 가상 머신의 C1, C2 컴파일러, 그랄 컴파일러
    - AOT 컴파일러: 그랄 컴파일러, JDK용 jaotc, 자바용 GNU 컴파일러(GCJ), 예흐켈시오르 JET
- 이번 장에서는 `프런트엔드 컴파일`에 집중
- `최적화`
    - 자바의 최적화는 런타임 컴파일러에 집중됨
- 런타임에는 실행 효율을 높이는 최적화를 JIT 컴파일러가 지속 수행, 컴파일타임에는 개발자의 코딩 효율을 높이는 최적화 수행(프런트엔드 컴파일러)

## javac 컴파일러

- javac는 컴파일러는 순수 자바로 작성됨

### javac 소스 코드와 디버깅

- JDK 6 이후, javac 컴파일러가 표준 자바 라이브러리로 옮겨짐(그전엔 tools.jar)
- jdk 컴파일 처리 단계
    - 단계 0: 플러그인 애너테이션 처리기들 초기화
    - 단계 1: 구문 분석 및 심벌 테이블 채우기
    - 단계 2: 플러그인 애너테이션 처리기들로 애너테이션 처리
        - 만약 새로운 심벌 생성되면 다시 구문 분석 심벌 테이블 채우는 단계로 돌아가야 함
    - 단계 3: 의미분석 및 바이트 코드 생성

### 구문 분석과 심벌 테이블 채우기

1. 어휘 및 구문 분석
    - 토큰(키워드, 변수 이름, 리터럴 연산자 등) 단위로 구문 분석
2. 심벌 테이블 채우기
    - 심벌 테이블: 심벌 주소, 심벌 정보의 집합으로 구성된 데이터 구조(해시 테이블 구조)
    - 컴파일 과정 곳곳에서 사용됨(의미 분석 과정중 의미 확인, 목적 코드 생성단계에서 주소 할당 등)

- 구문 분석 결과로 컴파일러는 프로그램 코드의 추상 구문 트리 얻음

### 애너테이션 처리

- JDK 5 애너테이션 도입
- JDK 6에서 플러그인 할 수 있는 애너테이션 처리 API 도입
- 플러그인 애너테이션 처리기로 할 수 있는 일는 일은 아주 다양
    - 롬복 등

### 의미 분석과 바이트코드 생성

- 의미 분석의 목적: 구조적으로 올바른 소스가 맥락상으로도 올바른지 확인하는 것
    - 타입 검사, 제어 흐름 검사,데이터 흐름 검사

1. 특성 검사
    - 변수 사용 시 선언돼있는지, 변수와 할당될 데이터 타입이 일치하는지 등 확인
    - 상수 접기
2. 데이터 흐름 분석과 제어 흐름 분석
    - 프로그램이 맥락상 논리적으로 올바른지 확인하는 추가 검사
    - 지역 변수 사용 전 값이 할당돼있는지, 메서드의 모든 경로에서 값을 반환하는지, 체크드 익셉션은 모두 올바르게 처리되는지 등
    - 컴파일 타임이나 런타임에만 수행되기도 함
    - final 키워드는 코딩 과정에서는 arg와 var 변수 간 변경 방지
        - but, 컴파일된 바이트코드엔 있으나 없으나 차이 없음
3. 편의 문법(syntactic sugar) 제거
    - 제네릭, 가변길이 매개 변수, 오토박싱/언박싱 등
    - 이런 구문은 런타임에 직접 지원 안 되므로 컴파일 과정 중 이 단계에서 기본 구문 구조로 복원
4. 바이트코드 생성
    - 이전 단계에서 생성한 정보(구문 트리, 심벌 테이블)를 바이트 코드 명령어로 변환하여 저장소에 기록
    -

## 자바 편의 문법의 재미난 점

- 거의 모든 프로그래밍 언어가 개발자가 코드를 더 쉽게 작성할 수 있도록 약간의 편의 문법 제공
- 반드시 유익한 것만은 아니라는 견해도 있음
- 프런트 엔드 컴파일러가 부리는 작은 속임수

### 제네릭

- 매개변수화된 타입, 매개변수화된 다형성
- 특수한 매개 변수를 사용하여 작업 대상의 데이터 타입을 지정할 수 있게 하는 것
- 자바와 C#은 제네릭을 구현하는 방식에서 매우 다른 길을 택함

#### 자바와  C#의 제네릭

- 자바가 선택한 제네릭 구현 방식: 타입 소거 제네릭
    - 컴파일 후 타입 정보 사라짐
- C#이 선택한 제네릭 구현 방식: 구체화된 제네릭
    - 컴파일 후 타입 정보 남아 있음
- C은 자바와 달리 박싱과 언박싱 거치지 않아 성능상 이점

#### 제네릭의 역사적 배경

- 자바가 이러한 선택을 한 이유: 자바 제네릭은 javac 컴파일러가 담당하여, 바이트 코드나 JVM 변경 안 해도 됨
    - 자바가 천명한 바이너리 하위 호환성 때문
- 제네릭 도입 하면서 자바는 대상 타입의 제네릭 버전을 추가하는 대신 기존 대상 타입을 모두 제네릭 버전으로 변경하는 선택을 함
    - 이전에 Vector와 ArrayList, Hashtable과 HashMap 등의 사례 때문

#### 타입 소거

- ArrayList<Integer>, ArrayList<String>은 모두 ArrayList의 하위 타입
- 원시 타입: 타입이 같은 모든 제네릭 인스턴스의 공통 상위 타입(<-> 제네릭 타입)
- 컴파일 타임에 제네릭 타입을 원시 타입으로 변환한다음, 필요한 형 변환 코드를 적절히 추가하여,
    - 원소가 추가되거나 수정될때마다 확인
- 타입 소거 방식 단점
    - 기본 타입 데이터 지원하는 데 문제
    - 런타임에 제네릭 타입 정보 얻을 수 없어 일부 코드 매우 장황해짐
    - 객체 지향 사고의 우아함을 일부 상실(제네릭 파라미터 달라도 오버로딩 불가한 경우 발생)

#### 값 타입과 앞으로의 제네릭

- 발할라 프로젝트에서 개선 계획
    - 아직 미흡
- 값 타입 도입
    - 발할라 프로젝트에서는 값 타입 지원 위해 value, primitive 키워드 추가 계획

### 오토박싱, 오토언박싱, 개선된 for 문

- 책 참조

### 조건부 컴파일

- C 언어 등의 조건부 컴파일
    - 자바에서는 if 문의 조건에 상수(true, false) 넣으면 됨

## 실전: 플러그인 애너테이션 처리기 제작

### 목표

- 애너테이션 처리기 API를 사용하여 코딩 스타일 검증하는 도구: NameCheckProcesser
- 전문 도구 수준은 과하고 코드에 쓰인 이름만 확인
- 자바 네이밍 컨벤션
    - 클래스, 인터페이스: 대문자 시작 캐멀 캐이스(파스칼 케이스)
    - 메서드: 소문자 시작 캐멀 케이스
    - 필드
        - 클래스 변수와 인스턴스 변수: 소문자 시작 캐멀 케이스
        - 상수: 대문자 스네이크 케이스

### 코드 구현

- 책 참조

### 실행 및 테스트

- 책 참조

### 다른 응용 사례

- 하이버네이트 밸리데이터 애너테이션 프로세서
- 롬복
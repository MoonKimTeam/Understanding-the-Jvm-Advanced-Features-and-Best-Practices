# 클래스 로딩과 실행 서브시스템, 사례와 실전

## 사례 연구

### 톰캣:정통클래스 로더 아키텍처

톰캣, 제티, 웹로직, 웹스피어 등 주요 자바 웹 서버는 모두 자체 정의한 클래스 로더를 사용한다. 이는 단순히 클래스 파일을 로딩하는 것이 아니라, 여러 개의 웹 애플리케이션이 하나의 서버에 배포되어 있을 때 발생하는 문제들을 해결하기 위한 구조적 설계의 일부이다. 따라서 이들은 일반적으로 두 개 이상의 클래스 로더를 혼용하며 다음과 같은 요구사항을 충족한다.

같은 서버에 배포된 서로 다른 웹 애플리케이션은 자바 클래스 라이브러리를 독립적으로 사용해야 한다. 즉, 같은 서버에 있더라도 애플리케이션마다 필요한 클래스 버전이 다를 수 있기 때문에, 클래스 충돌 없이 각 애플리케이션이 독립적으로 클래스 로딩을 할 수 있어야 한다. 이를 위해 각 웹 애플리케이션은 자신만의 클래스 로더를 가져야 하며, 이는 기본적인 요구사항이다.

반대로, 같은 서버에 배포된 웹 애플리케이션들 간에 공유 가능한 자바 클래스 라이브러리도 있다. 예를 들어, 스프링 프레임워크와 같은 공통 라이브러리는 서버에 한 번만 로딩하고 여러 애플리케이션이 공유하여 사용할 수 있어야 한다. 디스크 공간보다 중요한 것은 메모리 공간이며, 동일한 라이브러리를 여러 번 읽어들이는 것은 낭비다. 따라서 공통 클래스는 공유 클래스 로더를 통해 한번만 메모리에 로딩되도록 설계해야 한다.

서버는 또한 보안을 위해 각 애플리케이션이 서로 간섭하지 못하도록 해야 한다. 특히, 서버 자체의 클래스와 애플리케이션 클래스는 분리되어야 하며, 보안상 서버가 사용하는 클래스는 애플리케이션의 클래스 로더와 별도로 로딩되도록 설계되어야 한다.

JSP 파일을 다룰 때는 핫스왑 기능을 제공하는 웹 서버가 많다. JSP는 런타임 중에 수정될 가능성이 높기 때문에, 서버는 JSP 변경을 감지해 즉시 클래스 로더를 새로 만들어 핫스왑을 수행한다. ASP, PHP 등 스크립트 기반의 언어와 마찬가지로 JSP도 수정 즉시 적용되도록 만들어야 한다. 그러나 모든 서버가 이 기능을 제공하지는 않으며, 일부 서버는 프로덕션 환경에서는 JSP 변경을 금지하기도 한다.

이처럼 다양한 요구사항이 존재하기 때문에 하나의 클래스패스로 모든 웹 애플리케이션을 관리하는 것은 적절하지 않다. 실제로 톰캣은 다양한 디렉터리에 클래스 라이브러리를 분산 배치하며, 클래스 로더를 계층적으로 구성해 이들을 관리한다. 톰캣 기준으로는 /common, /server, /shared, /webapp/WEB-INF 총 4개의 주요 디렉터리를 사용하며, 각 디렉터리에 담긴 클래스는 다음과 같은 범위에서 활용된다. /common은 톰캣 자체와 모든 웹 애플리케이션이 사용하는 공통 라이브러리, /server는 톰캣 자체, /shared는 톰캣을 제외한 웹 애플리케이션들만 사용하는 클래스, /webapp/WEB-INF는 개별 웹 애플리케이션에서만 사용하는 클래스이다.

이러한 디렉터리 구조에 따라 톰캣은 부트스트랩 클래스 로더, 플랫폼 클래스 로더, 애플리케이션 클래스 로더, 공통 클래스 로더(CommonClassLoader), 카탈리나 클래스 로더(CatalinaClassLoader), 공유 클래스 로더(SharedClassLoader), 웹앱 클래스 로더(WebappClassLoader), JSP 클래스 로더(JspClassLoader) 등 총 5~7개의 계층 구조를 갖는 클래스로더 아키텍처를 사용한다. 특히 웹앱 클래스 로더는 각각의 웹 애플리케이션마다 별도의 인스턴스로 존재하며, 클래스 충돌을 방지하는 중요한 역할을 수행한다.

공통 클래스 로더는 카탈리나와 공유 클래스 로더 모두에서 사용할 수 있는 클래스를 로딩하지만, 카탈리나나 공유 로더에서 로딩한 클래스는 서로 격리된다. JSP 클래스 로더는 JSP 파일을 컴파일해 생성한 클래스 파일만 로딩하며, 변경된 JSP 파일이 감지되면 기존 JSP 클래스 로더 인스턴스를 대체하여 핫스왑을 수행한다.

톰캣 6부터는 디렉터리 구조가 단순화되어 common, server, shared 디렉터리를 하나로 통합하는 경향이 있으며, lib 디렉터리만 남기고 클래스 로더 역할을 단순화하는 방향으로 나아가고 있다. 필요 시에는 tomcat/conf/catalina.properties에서 server.loader와 shared.loader를 지정해 전통적인 전체 로더 아키텍처를 구성할 수도 있다.

톰캣의 정통 클래스 로더 아키텍처는 명확한 규약에 따라 구성되기 때문에 공식 문서를 기반으로 이해하기 쉽고, 웹 서버의 설계 목적과 구조를 파악하는 데 효과적이다. 이는 클래스 로더의 ‘수직’ 사용에 익숙해지는 데도 도움이 되며, 실전에서는 이 구조를 기반으로 프레임워크나 사용자 코드가 어떤 방식으로 클래스에 접근하는지를 판단할 수 있게 한다. 스프링 프레임워크를 예로 들어 웹 애플리케이션이 여러 개 있을 경우, 공통 또는 공유 클래스 로더의 로딩 범위 밖에 있는 사용자 코드와의 연결을 어떻게 해결할 것인지 고민하게 만들며, 이러한 상황을 통해 클래스 로더 설계를 보다 깊이 있게 이해할 수 있다

### OSGi: 유연한 클래스 로더 아키텍처 

자바 개발 커뮤니티에서는 자바 EE 명세나 클래스 로더 관련 지식을 습득할 때 JBoss 소스 코드와 OSGi 소스 코드를 각각 최고로 평가한다. 이 말은 OSGi가 자바 클래스 로더를 다루는 방식이 매우 독특하다는 것을 의미한다. OSGi는 IBM 등이 이끄는 연합체에서 제창한 자바 기반 ‘동적’ 모듈 명세로, 초기에는 심지어 썬도 참여했다. 이 명세의 목적은 서비스 제공자가 다양한 가정용 스마트 기기를 포함한 환경에 게이트웨이를 통해 서비스를 제공할 수 있게 하는 것이었고, 자바의 다른 기술과 달리 실제 산업적으로 매우 실질적인 활용도를 보이며 스마트 시티, 산업 자동화, 4차 산업 등에서 활용되고 있다.

OSGi는 전통적인 자바 클래스 로더 사용 방식과 달리, 각 모듈(번들)이 자신의 클래스 로더를 가지며, 일반적인 JAR 형식으로 패키징된다. 다만, 번들은 자신이 의존하는 외부 패키지를 Import-Package 방식으로 선언하고, 외부로 공개할 패키지는 Export-Package 방식으로 명시적으로 선언해야 한다. 이로 인해 모듈 간 클래스 참조 범위가 매우 정밀하게 제어된다. 어떤 번들은 명시적으로 공개하지 않은 패키지에 대해 접근을 차단하며, Export-Package로 지정되어 있지 않으면 다른 번들이 해당 클래스를 로딩하려 해도 실패한다. 이 같은 설계는 모듈 간의 의존성과 캡슐화를 엄격히 구분하기 위함이다.

OSGi는 원래 ‘정적’ 모듈 명세로 시작되었지만, JDK 9부터 자바 모듈 시스템이 등장하면서 기존 OSGi 기능 중 일부가 중복되기도 한다. 현재는 ‘동적’ 모듈 시스템 개선 쪽으로 집중하고 있으며, 이는 프로그램이 실행 중에도 일부 모듈을 ‘비활성화 → 재설치 → 활성화’하는 작업을 수행할 수 있는 점에서 매우 유연하다. 특히, 이클립스 같은 대규모 소프트웨어는 수많은 모듈을 필요로 하기 때문에 이러한 유연한 구조가 큰 장점이 된다.

OSGi에서는 모듈 간 클래스 로더 간에 고정된 부모-자식 위임 모델이 존재하지 않는다. 대신, 패키지 의존성을 기반으로 한 유연한 로딩 방식이 적용된다. 예를 들어 번들 A가 번들 B의 패키지 b01을 의존한다고 선언하면, 해당 패키지에 포함된 클래스는 번들 B의 클래스 로더를 통해 로딩된다. 하지만 이 의존 관계가 없다면 번들 A는 번들 B의 클래스를 로딩할 수 없다. 각 번들은 자신이 명시적으로 선언한 패키지 외에는 접근할 수 없으며, 명시적 선언 없이 다른 번들의 클래스를 로딩하려고 해도 OSGi 프레임워크는 요청을 무시한다.

클래스 로딩 순서는 java.*로 시작하면 부모 클래스 로더에서 먼저 시도하며, 그렇지 않으면 번들의 의존 목록, 현재 번들의 클래스패스, 프래그먼트 번들, 동적 의존 목록, 마지막으로는 로딩 실패 순으로 진행된다. 이러한 방식은 부모 위임 모델을 따르지 않고, 번들 간 명시적 선언에 따라 로딩 범위를 통제한다.

실제로는 이런 유연함이 동시성 문제와 충돌 가능성을 키우기도 한다. 예를 들어 번들 A와 번들 B가 서로의 패키지를 참조하고 있고, A에서 B를 참조한 후 B에서 다시 A를 참조하려 하면 교착 상태가 발생할 수 있다. 이러한 문제 때문에 OSGi 구현체에서는 osgi.classloader.singleThreadLoads 설정을 통해 클래스 로딩을 단일 스레드로 제한하기도 한다.

이러한 문제를 해결하기 위한 JDK 차원의 개선도 JDK 7부터 반영되었으며, 대표적으로 ClassLoader.registerAsParallelCapable() 메서드를 통해 병렬 클래스 로딩이 가능해졌다. 기존에는 ClassLoader 객체 단위로만 동기화됐던 것을 이름 단위로 정리하게 되어 병목을 줄였다.

전반적으로 OSGi는 강력한 모듈 시스템을 갖추고 있으며, 각 모듈이 명확하게 경계를 가지는 점이 특징이다. 이는 유지보수성과 확장성 면에서 큰 장점이 되며, 다양한 서비스 구현에 적합하다. 하지만 모든 애플리케이션에 적합한 것은 아니며, 초기 설계에서부터 OSGi를 고려하지 않으면 도입이 복잡해지고 추가적인 위험이 발생할 수 있다. 기능이 강력한 만큼 구조적 복잡성과 잠재적인 충돌 가능성에 주의해야 한다.

### 바이트코드 생성 기술과 동적 프락시 구현

이트코드 생성 기술은 고급 기술이 아니라 걱정할 필요 없다. 이 절에서는 Javassist, CGLib, ASM 같은 바이트코드 조작 라이브러리를 다루지 않고, javac 컴파일러와 동적 프락시를 중심으로 설명한다. javac는 JDK에 포함된 컴파일러로, 자바 코드를 바이트코드로 변환하는 기술의 핵심이며, 이 역시 자바 코드로 작성되어 있다. OpenJDK의 src 디렉터리 내에 위치한 com.sun.tools.javac 패키지에 해당 소스 코드가 들어 있다. 이 소스를 참고하면 자바 코드가 어떻게 바이트코드로 컴파일되는지 그 원리를 이해하는 데 도움이 된다. 하지만 원리 파악 자체가 목적이라면 과한 접근이고, 실제 개발 세계에서는 다양한 바이트코드 생성 사례가 존재한다. 예를 들어 JSP 컴파일러는 런타임에 JSP를 바이트코드로 컴파일하여 실행하며, AOP 프레임워크나 동적 프락시 기술에서도 바이트코드 생성을 적극적으로 활용한다.

동적 프락시는 그중에서도 자바 개발자가 자주 접하게 되는 기술 중 하나로, 이번 절에서는 비교적 단순한 예제를 통해 설명하고 있다. 특히 스프링에서는 동적 프락시를 자주 사용하며, 내부적으로 java.lang.reflect.Proxy와 InvocationHandler 인터페이스를 활용한다. 직접적으로 Proxy를 사용하는 일은 드물지만, 내부적으로 다양한 기능이 이 메커니즘을 기반으로 작동한다. Proxy는 런타임에 자바 바이트코드를 생성하여 프락시 클래스를 만들고, 이 클래스는 원래 인터페이스를 구현하며, 메서드 호출 시 동적으로 InvocationHandler의 invoke() 메서드를 실행한다.

책에서는 간단한 예제로 sayHello()를 출력하는 Hello 클래스를 정의하고, 이를 동적 프락시로 감싸서 sayHello() 실행 전에 “Welcome”을 출력하도록 프락시를 구성했다. 핵심은 Proxy.newProxyInstance() 메서드를 통해 동적으로 프락시 인스턴스를 생성하며, 이 인스턴스는 Hello 클래스가 구현한 IHello 인터페이스를 기반으로 동작한다. 실제 프락시 클래스는 ProxyGenerator.generateProxyClass() 메서드를 통해 바이트코드가 생성되며, 프로그램이 실행되면 프락시 클래스가 메모리에 로딩되고, 그 안에 정의된 invoke() 메서드가 호출된다. 이 메서드는 먼저 “Welcome”을 출력하고, 이후 원래 객체의 메서드를 호출한다. 결과적으로 콘솔에는 “Welcome”과 “hello world”가 출력된다.

책에서는 이 프락시 클래스가 어떻게 바이트코드로 구성되는지를 자세히 보여주기 위해 디컴파일된 코드를 제시하고 있다. $Proxy0 클래스는 Proxy를 상속하며, DynamicProxyTest$IHello 인터페이스를 구현한다. 내부에는 Method 객체들이 캐시되고, static 블록에서 리플렉션을 통해 이 객체들을 초기화한다. 핵심적인 동작은 sayHello() 메서드 안에서 super.h.invoke(…)를 호출하여 위임 객체로 등록된 InvocationHandler의 invoke() 메서드를 실행하는 것이다. 결과적으로 InvocationHandler에 설정된 로직이 실행되며, 실제 비즈니스 로직은 원래 객체의 메서드를 통해 실행된다.

이와 같은 구조는 매우 간단하면서도 강력한 기능을 제공하며, 다양한 프레임워크에서 널리 활용된다. 실제 바이트코드 생성 과정은 ProxyGenerator.generateProxyClass()가 처리하지만, 그 내부 로직은 명시적으로 설명되어 있지 않다. 클래스 파일 포맷에 맞춰 바이트코드를 생성하며, 일반적으로는 직접 생성하기보다 JDK에 포함된 클래스 라이브러리를 활용하는 편이 훨씬 효율적이다.

JDK에서 ProxyGenerator의 소스 코드는 src/java.base/share/classes/java/lang/reflect 디렉터리에 위치하고 있으며, 이 코드를 분석하면 바이트코드 생성의 실제 구현 방식과 구조를 더 깊이 알 수 있다.

### 백포트 도구: 자바의 타임머신

소프트웨어 프로젝트를 시작한 지 얼마 되지 않은 기업은 새로운 기술을 적용하거나 프레임워크를 교체하는 데 비교적 유연하다. 예컨대 JDK를 최신 버전으로 업그레이드하거나 자바를 C#과 같은 언어로 대체하는 일도 가능하다. 하지만 기업이 성장하고 기술 자산이 누적되면서 개발의 중심은 기술이 아닌 제품으로 이동하게 된다. 기술을 독립적으로 선택할 수 있는 자유는 줄어들고 기존 기술과 코드에 대한 의존도가 높아진다. 이렇게 축적된 코드와 기술은 수익과 직결되기 때문에 쉽게 변경하지 못하며, 안정성을 중시하는 팀은 검증된 기술을 고수하게 된다. 그러나 빠르게 변화하는 IT 업계에서는 매일 새로운 기술이 등장하고 개발자를 유혹하는 데, JDK 역시 주요 릴리스마다 새로운 문법과 기능을 도입하면서 개발 습관과 생산성에 많은 영향을 주었다.

JDK 5에는 오토박싱, 제네릭, 애너테이션, 열거형, 개선된 for문 등이 도입되었고, JDK 8에는 람다식과 스트림 API, 디폴트 메서드가 추가되었다. 이후 JDK 911에서는 지역 변수 타입 추론, JDK 1217에서는 switch 표현식, 텍스트 블록, instanceof 패턴 매칭 등 구문적 개선이 이루어졌으며, JDK 18~21에서는 레코드 패턴과 switch 문 패턴 매칭 기능이 도입되었다. 이런 문법적 향상은 과거에는 불가능했던 코드 간결성과 생산성을 가능하게 했다.

하지만 회사 정책상 여전히 구 버전 JDK를 사용해야 하는 상황도 존재한다. 예를 들어 FHD 환경의 19인치 모니터에서 개발하다가 4K 환경의 32인치 모니터로 변경되면 시야와 생산성이 개선되듯, 개발 환경의 변화는 프로그램 작성에 직접적인 영향을 끼친다. 그러나 어떤 기업은 기존 코드 및 시스템 안정성을 이유로 최신 JDK로 업그레이드하지 못하고, 심지어는 JDK 8 이하의 버전을 고수해야 한다. 이 문제를 해결하기 위한 도구로 ‘백포트 도구’가 등장했다. 대표적인 도구로는 레트로트랜슬레이터(Retrotranslator), 레트로람다(Retrolambda), 제이블(Jabel)이 있다.

레트로트랜슬레이터는 JDK 5에서 등장한 클래스 파일을 JDK 1.4 또는 1.3에서 사용 가능하도록 변환해 주며, 오토박싱, 제네릭, 개선된 for문 등을 포함할 수 있도록 해준다. 제이블은 JDK 9~14의 언어 기능을 JDK 8 이하 환경에서 사용할 수 있도록 변환해 주며, JDK 7 이전의 환경에서는 java.lang.invoke 패키지 같은 기능을 제한적으로 제공한다.

레트로람다는 JDK 8의 람다식을 JDK 5~7에서도 사용할 수 있도록 바이트코드를 변환하는 방식으로 작동한다. 이 도구들은 javac의 컴파일 타깃 설정, 예를 들어 javac -target 1.5 옵션을 통해 컴파일된 코드를 낮은 버전에서도 실행되게 변환하며, 동시에 invokeDynamic 명령을 대체하는 방식으로 람다를 처리한다. 예를 들어 Retrolambda는 invokeDynamic 명령 없이도 기존 명령어 조합만으로 람다 표현식을 구현할 수 있도록 해준다.

백포트 도구는 자바 API, 컴파일러, 바이트코드, 구조적 차이, JVM 내부 구조 등 다양한 차원에서 하위 호환을 위해 복합적으로 동작한다. 예를 들어 자바 5에서 도입된 동시성 API는 java.util.concurrent 패키지에 포함되어 있지만, JDK 8 이전에는 이를 직접 사용할 수 없었다. 이에 대해 일부 도구들은 해당 API와 유사한 라이브러리를 백포트하거나 자체 구현된 유틸리티로 대체하여 제공한다. 이처럼 백포트 도구는 특정 JDK 버전에 종속된 자바 코드를 하위 버전에서도 실행 가능하게 만들기 위해 다양한 방식으로 동작하며, 일부 도구는 내부적으로 바이트코드를 ASM 등의 프레임워크를 이용해 조작하기도 한다.

레트로트랜슬레이터는 JDK 5에서 추가된 열거형 클래스인 java.lang.Enum을 자체적으로 대체 라이브러리로 구현하며, 클래스의 필드 접근, 메서드 구현 등도 새로운 방식으로 재작성한다. 이는 단순한 문법 변경이 아닌, 상당히 복잡한 구조적 변환을 요구하는 고급 기법이다.

## 실전: 원격 실행 기능 직접 구현하기

프로그램을 유지 보수하다 보면 특정 매개변수의 값을 확인하거나 캐시 내부 데이터를 점검하고 싶은 상황을 자주 겪는다. 하지만 로그나 화면에 값을 출력하는 코드가 없어 원인을 쉽게 파악하지 못하거나, 캐시에 접근할 수 있는 인터페이스가 없어 데이터를 확인할 방법이 없어서 결국 서비스 재시작과 캐시 초기화를 선택하게 되는 경우도 있다.

이러한 문제들의 공통점은 작은 코드 조각만 실행할 수 있다면 문제를 쉽게 해결할 수 있다는 점이다. 하지만 일반적인 서버 애플리케이션은 외부에서 임의 코드를 서버 내부에서 직접 실행할 방법을 제공하지 않기 때문에, 프로그램을 유지하면서도 발생하는 문제 해결이 쉽지 않다.

이 문제를 해결하기 위한 일반적인 방법으로는 여러 가지가 있다. 예를 들어 BTrace 같은 JVMTI 도구를 사용해 프로그램의 특정 코드를 동적으로 수정할 수 있고, JDK 6 이후부터는 컴파일러 API를 통해 자바 코드를 런타임에 컴파일하고 실행할 수 있다. 또 다른 방법으로는 JSP 파일을 작성해 서버에 업로드하고 브라우저에서 실행하거나, 브라우저 기반의 스크립트 실행 엔진을 서버에 설치해 서버 애플리케이션 내에서 동적 스크립트를 수행할 수도 있다. 또는 애플리케이션 자체에 동적 실행 기능을 내장해두는 방식도 존재한다.

### 아이디어 구상

원격 실행 기능을 직접 구현하려는 아이디어는 유지 보수를 하다 보면 발생할 수 있는 문제 상황에서 출발한다. 예를 들어 특정 매개변수의 값을 확인하고 싶어도 출력할 방법이 없거나, 캐시에서 데이터를 못 찾고 있는데도 캐시를 관리하는 인터페이스가 없어 어쩔 수 없이 서비스를 재시작해야 하는 상황 등이 대표적이다. 이런 문제들의 공통점은, 작은 코드 조각만 실행할 수 있다면 원인을 찾거나 문제를 제거할 수 있다는 점이다. 그러나 대부분의 시스템은 서버에서 임시 코드를 실행할 방법이 없는 구조다. 이처럼 프로젝트 운영 중 자주 마주치는 문제를 해결하기 위한 현실적인 방법으로 원격 실행 기능이 필요해진다.

일반적으로는 BTrace나 JVMTI 같은 도구를 이용해 프로그램의 특정 코드를 동적으로 수정하거나, JDK 6 이후 제공되는 컴파일러 API를 통해 자바 코드를 동적으로 컴파일해 서버에 임시 코드를 실행시키는 방식이 있다. 또한 JSP 파일을 작성해서 서버에 업로드하고 실행하거나, 아예 애플리케이션에 동적 실행 기능 자체를 내장할 수도 있다. 여기서는 클래스 로딩과 가상 머신 실행 서비스 시스템을 기반으로, 앞에서 학습한 내용을 되짚으며 서버에서 임시 코드를 직접 실행하는 과정을 실습하려 한다.

이를 구현하기 위해 해결해야 할 세 가지 과제가 있다. 첫째는 서버에 제출된 자바 코드를 컴파일하는 것이다. 이는 두 가지 방식이 있다. 하나는 서버에서 직접 컴파일하는 방식으로, JDK 6부터 지원되는 컴파일러 API를 이용하거나, 이전 JDK에서는 JAVA_HOME/lib/tools.jar에 포함된 com.sun.tools.javac.Main 클래스를 사용하는 방법이 있다. 하지만 이는 특정 JDK에 의존해야 하는 단점이 있다. 예를 들어 JRockit이나 J9 같은 일부 JDK는 해당 jar 파일을 포함하지 않기 때문에 모든 환경에서 동작을 보장할 수 없다. 다른 방식으로는 클라이언트에서 미리 컴파일을 수행하고, 바이트코드를 서버에 전달하는 방법이 있다. 이는 클라이언트 측에 필요한 컴파일 환경이 갖추어져 있어야 한다는 점에서 다소 복잡하지만, 서버 환경의 제약을 피할 수 있는 장점이 있다.

두 번째 과제는 컴파일된 자바 코드를 실행하는 것이다. 이를 위해 클래스 로더를 이용해 클래스를 로딩하고, 객체를 생성한 뒤 리플렉션을 통해 메서드를 호출한다. 이때 반드시 main 메서드를 강제하지 않아도 되므로 유연하게 사용할 수 있지만, 한편으로는 일회성 실행이 끝나지 않아 자원 누수가 발생할 가능성도 있다. 동일한 클래스가 반복적으로 제출되고 실행될 수 있으므로, 클래스 로딩과 언로드가 자연스럽게 이루어질 수 있도록 구조를 고려해야 한다. 임시 코드이기 때문에 실행 후 언로드가 가능하며, 재활용도 고려할 수 있다.

세 번째 과제는 실행 결과를 수집하는 것이다. 보통은 표준 출력(System.out)이나 표준 오류(System.err)에 출력된 내용을 수집하면 되지만, 이는 가상 머신 전체에서 공유되는 리소스이기 때문에 주의가 필요하다. System.setOut()과 System.setErr() 메서드를 통해 출력 스트림을 지정하면 PrintStream 객체로 출력을 수집할 수 있으나, 이 역시 다른 스레드에 영향을 줄 수 있다. 원래 프로그램에 영향을 주지 않으면서 출력 결과만 수집하고 싶다면 PrintStream을 이용한 심볼 참조를 활용해야 한다.

### 구현

첫 번째 도구는 HotSwapClassLoader 클래스이다. 이 클래스는 이름에서 알 수 있듯이 같은 클래스의 코드를 여러 번 로드할 수 있도록 도와주는 기능을 담당한다. 내부적으로는 ClassLoader를 상속하고, defineClass 메서드를 통해 바이트 배열을 클래스 객체로 변환하여 로딩하는 구조로 되어 있다.

HotSwapClassLoader는 기본적으로 부모 클래스의 protected 메서드인 defineClass를 호출하여 바이트 배열로부터 클래스를 로딩하지만, 기존의 findClass 메서드를 오버라이딩하지 않기 때문에 부모의 탐색 범위를 거치지 않고 직접 로드하는 방식으로 구현되어 있다. 따라서 동일한 클래스를 여러 번 로드할 수 있다. 이때 HotSwapClassLoader는 ClassModifier가 처리한 byte[] 배열을 입력으로 받아 로딩한다.

ClassModifier는 클래스 파일의 상수 풀 영역을 직접 수정하는 기능을 한다. 주로 java.lang.System 클래스를 HackSystem 클래스로 대체하기 위해 사용되며, 내부적으로 CONSTANT_Utf8_info 상수 항목을 수정하는 방식으로 구현되어 있다. 예를 들어 기존 클래스 파일 내의 문자열 “java/lang/System”을 “org/fenixsoft/jvm/chapter9/HackSystem”으로 바꾸는 작업을 수행한다. 이를 위해 ByteUtils 클래스가 함께 사용되는데, ByteUtils는 바이트 배열의 변환과 치환 작업을 수행하는 도우미 역할을 한다. bytes2Int, int2Bytes, bytes2String, string2Bytes, bytesReplace 등의 메서드를 통해 바이트 단위 조작을 수행하며, modifyUTF8Constant 메서드 내부에서 핵심적으로 활용된다.

HackSystem 클래스는 java.lang.System을 대체하는 역할을 하며, System.out과 System.err을 자신이 정의한 PrintStream 객체로 바꾸어 프로그램 출력 결과를 수집할 수 있도록 한다. 내부적으로는 ByteArrayOutputStream을 사용하여 출력 버퍼를 만들고, 이를 기반으로 PrintStream을 생성하여 모든 출력이 이 버퍼에 저장되도록 한다. 이후 getBufferString 메서드를 통해 출력된 내용을 문자열 형태로 가져올 수 있고, 필요 시 clearBuffer 메서드를 통해 출력 버퍼를 초기화할 수 있다.

마지막으로 핵심 클래스인 JavaclassExecuter 클래스가 이 모든 도우미 클래스를 조합하여 실제 실행을 수행한다. execute 메서드는 먼저 HackSystem.clearBuffer를 호출하여 출력 버퍼를 초기화하고, ClassModifier를 통해 전달받은 클래스 파일 바이트 배열의 “java/lang/System” 문자열을 HackSystem으로 변경한다. 이후 수정된 byte[] 배열을 HotSwapClassLoader를 통해 로딩하고, 생성된 클래스 객체에서 리플렉션을 통해 main 메서드를 찾아 실행한다. 만약 이 과정에서 예외가 발생하면 HackSystem.out으로 예외 내용을 출력하고, 실행이 종료되면 HackSystem에 저장된 출력을 문자열로 반환하여 실행 결과를 전달한다.

이 구조는 매 실행마다 클래스 로더 인스턴스가 새로 생성되므로 같은 클래스도 반복해서 로딩할 수 있으며, main 메서드를 실행하는 데 있어 외부 클래스와의 의존을 제거하면서도 출력 결과를 캡처할 수 있는 완전한 샌드박스 환경을 구현한다. 이로써 원격 코드 실행 기능을 위한 기반 구성이 완성된다.

### 검증

지금까지 구현한 원격 실행 기능이 의도한 대로 동작하는지를 확인하기 위해 간단한 검증을 진행한다. 검증의 목적은 단순히 System.out에 정보를 출력하는 TestClass 클래스를 만들어 실행해보는 것이다. 이때 검증용 클래스 파일은 C 드라이브 루트 디렉터리에 저장하고, JSP를 통해 해당 클래스의 바이트코드를 읽어 서버에서 실행한 후 결과를 출력하는 방식을 사용한다.

실제로 JSP가 출력하는 결과에는 TestClass 클래스의 main 메서드가 실행되며 생성한 출력이 포함된다. 이 과정을 통해 앞서 구현한 HotSwapClassLoader, ClassModifier, HackSystem, JavaclassExecuter 등의 조합이 정상적으로 동작함을 확인할 수 있다. 실행 결과는 웹 브라우저에서 JSP 파일을 호출함으로써 즉시 확인 가능하다.

# 클래스 로딩과 실행 서브시세틈, 사례와 실전

## 사례 연구

### 톰캣: 정통 클래스 로더 아키텍처

톰캣, 제티, 웹로직, 웹스피어 등 주류 자바 웹 서버는 모두 자체 정의한 클래스 로더를 사용한다. <br>
이때 다음과 같은 문제들을 해결해야 하기 때문에 일반적으로 둘 이상의 로더를 혼용한다.

- 똑같은 서버에 배포하더라도 자바 클래스 라이브러리를 웹 애플리케이션별로 격리하는 게 좋다. <br>
  같은 서드 파티 클래스 라이브러리를 이용하더라도 애플리케이션마다 필요로 하는 버전은 다를 수 있다. 즉, 클래스 라이브러리들은 한 서버에 여러 버전이 공존할 수 있다.
- 똑같은 서버에 배포된 둘 이상의 웹 애플리케이션이 사용하는 자바 클래스 라이브러리는 서로 공유할 수 있다. <br>
  예를 들어 서버 한 대에 스프링 프레임워크를 사용하는 애플리케이션을 열 개 배포했다고 해 보자. 스프링 프레임워크를 열 벌이나 복사해 관리한다면 자원 낭비가 크다. <br>
- 서버는 보안을 최대한 유지해서 배포된 웹 애플리케이션들의 영향을 받지 않아야 한다.
- JSP 애플리케이션을 지원하는 웹 서버는 대부분 핫 스와프를 지원한다. JSP 파일은 서드 파티 클래스 라이브러 리나 자바로 작성된 코드보다 런타임에 수정될 가능성이 훨씬 크다. <br>
  주류 웹 서버는 JSP로부터 생성된 클래스의 핫 스와프를 지원해야 한다. 하지만 모두가 그렇지는 않다. 예컨대 웹로직 서버는 프로덕션 모드에서는 기본적으로JSP 파일이 변경되는 걸 허용하지 않는다.

이상의 조건들 때문에 클래스패스가 하나뿐인 구조는 다수의 웹 애플리케이션을 배포하기에 적합하지 않다. <br>
그래서 다양한 웹 서버에서 서드 파티 클래스 라이브러리 저장용으로 별도의 클래스패스를 제공하기도 한다. <br>
이때 주로 쓰이는 경로명은 lib, classes다.

톰캣에서는 자바 클래스 라이브러리 저장용 디렉터리 3개 (/common/*, /server/*, /shared/*)와 웹 애플리케이션 자체 저장용 디렉터리 1개(/WEB-INF/*)를 합해 총 4개의 디렉터리가 핵심이다. <br>

- /common: 톰캣 자신과 모든 웹 애플리케이션
- /server: 톰캣 자신
- /shared: 톰캣을 제외한 모든 웹 애플리케이션
- /webapp/WEB-INF: 해당 웹 애플리케이션


### OSGi: 유연한 클래스 로더 아키텍처

> 자바 EE 명세를 배우려면 JBoss 소스 코드를 읽어보는게 최고이고, <br>
> 클래스 로더 관련 지식을 얻으려면 OSGi 소스 코드를 보는게 최고다.

OSGi는 IBM 등이 이끄는 OSGi 연합에서 제창한 자바 기반 동적 모듈 명세이다. <br>
OSGi의 목적은 서비스 제공자가 다양한 가정용 스마트 기기를 하나의 게이트웨이를 통해 제공하는 것이었다. 그 후 자바의 다른 기술 영역에서도 매우 잘 받아들여져서 スト바 세계의 '실질적인 동적 모듈 표준이 되었다. <br>
OSGi에서는 모듈 간에 클래스 라이브러리 가시성이 매우 정밀하게 제어된다. 오직 모듈이 명시적으로 공개한 패키지만 외부에서 접근할 수 있다. <br>
오늘날 OSGi를 도입하는 주된 이유는 OSGi 아키텍처를 기반으로 개발하면 모듈 수준에서 핫 스와프를 구현하기 쉽기 때문이다. <br>
프로그램을 업데이트하거나 디버깅할 때 프로그램의 일부만 비활성화 -> 재설치 -> 활성화 할 수 있다.

OSGi가 이처럼 매력적인 기능을 제공할 수 있는 근간에는 유연한 클래스 로더 아키텍처가 있다. <br>
예를 들어 번들 A가 번들 B의 패키지 b1에 의존한다고 선언했다고 해 보자. 그렇다면 패키지 bl에 속한 모든 클래스의 로딩은 번들 B의 클래스 로더에 위임된다. <br>
특정 패키지로 서로 연관되지 않은 번들 클래스 로더끼리는 서로 독립적이다. 즉, 번들들이 어떤 패키지를 공개하고 의존하느냐에 따라 번들 사이의 위임과 의존 관계가 만들어진다. <br>
또한 번들 클래스 로더는 다른 번들에 서비스를 제공할 때 공개 목록에 기초하여 접근 범위를 엄격하게 제어한다.

### 바이트코드 생성 기술과 동적 프락시 구현

자바 세계에는 컴파일타임에 코드를 변경해 주는 AOP 프레임워크가 있다. 동적 프락시 기술에도 흔히 쓰인다. <br>
리플렉션을 사용할 때도 가상 머신은 실행 속도를 개선하기 위해 런타임에 바이트코드를 생성하기도 한다. <br>
많은 자바 개발자가 동적 프락시를 사용한다. 특히 스프링을 사용해 봤다면 알게 모르게 동적 프락시를 사용했을 것이다. <br>
인터페이스로부터 생성한 빈이라면 스프링이 내부적으로 동적 프락시를 활용해 다양한 기능을 수행한다. <br>
동적 프락시의 장점은 프락시 클래스를 작성하는 코드 양을 줄여 주는 게 아니다. 원래의 클래스와 인터페이스가 무엇인지 알 수 없는 상태에서 프락시가 행위를 대신 결정할 수 있다는 점이 장점이다.

### 백포트 도구: 자바의 타임머신

JDK 버전 간 격차를 좁혀서 상위 버전 JDK로 작성된 코드를 하위 버전 JDK 환경에 배포할 수 있다. <br>
이를 위해 다양한 백포트 도구가 등장했으며, 대표적으로 Retrotranslator, Retrolambda, Jabel이 있다. <br>
Retrotranslator는 JDK 5에서 컴파일된 클래스를 JDK 1.4 또는 1.3에 배포할 수 있는 버전으로 변환해준다. <br>
오토박싱, 제네릭, 애너테이션, 열거형, 가변 길이 매개 변수, 개선된 for 문과 정적 임포트를 지원한다. 개선된 컬렉션, 동시성 패키지, 제네릭이나 애너테이션에 대한 리플렉션도 지원한다.


## 실전: 원격 실행 기능 직접 구현하기

프로그램을 유지 보수하다 보면 다음과 같은 상황을 겪을 수 있다.

- 당면한 문제의 원인을 찾기 위해 특정 매개 변수의 값을 확인하고 싶다. 하지만 그 값을 화면이나 로그에 출력할 방법이 없다.
- 캐시에서 특정 데이터를 찾지 못하고 있는데 캐시를 통합 관리해 주는 인터페이스가 없다. 어쩔 수 없이 서비스를 다시 시작해 캐시를 비워야 한다.

이상의 상황들에서 나타나는 공통된 특징은 무엇일까? <br>
바로 작은 코드 조각만 실행할 수 있다면 문제를 찾거나 제거할 수 있지만, 서버에서 임시 코드를 실행하도록 할 방법이 없다는 점이다.

### 목표

서버에서 임시 코드를 실행한다라는 요구사항에 앞서 목표는 다음과 같다.

- JDK 버전에 구애받지 않는 기능은 JDK 1.4 이상의 주류 JDK에서 구동할 수 있다.
- 원래 서버 프로그램 배포에 영향을 주지 않으며 서드 파티 클래스 라이브러리를 사용하지 않는다.
- 원래 프로그램을 침해하지 않는다. 즉, 원래 프로그램의 코드를 변경하지 않고 프로그램 동작에도 영향을 주지 않는다.
- 빈셸 스크립트나 자바스크립트 등에서는 자바 객체를 사용하기 불편하므로 임시 코드는 자바 언어를 직접 지원해야 한다.
- 임시 코드는 자유롭게 구현할 수 있어야 한다. 특정 클래스에 의존하거나 특정 인터페이스를 구현하지 않아도 된다.
- 클라이언트는 임시 코드의 실행 결과를 받아볼 수 있다.

### 아이디어 구상

목표한 프로그램을 구현하려면 다음 세 가지 문제를 해결해야 한다.

- 서버에 제출된 자바 코드 컴파일하기
- 컴파일된 자바 코드 실행하기
- 실행 결과 수집하기

#### 서버에 제출된 자바 코드 컴파일하기

먼저 서버에서 컴파일하는 방법이 있다. JDK 6부터는 컴파일러 API를 이요할 수 있다. <br>
또 다른 방법으로, 자바 코드를 클라이언트에서 컴파일한 다음 바이트코드를 서버에 전달할 수 있다.

#### 컴파일된 자바 코드 실행하기

클래스 로더가 클래스를 로드하여 클래스 객체를 생성한 다음 리플렉션을 이용해 메서드를 호출하도록 하면 된다. <br>
어떤 인터페이스도 강제하지 않기 때문에 main() 메서드를 호출하도록 할 것이다.

#### 실행 결과 수집하기

System.out과 System.err에서 내보낸 정보를 수집하도록 할 것이다.

### 구현

#### HotSwapClassLoader 클래스

같은 클래스의 코드를 여러 번 로드할 수 있다는 조건을 구현하는데 사용된다. <br>
HotSwapClassLoader는 그저 부모 클래스인 ClassLoader에서 protected로 정의한 defineClass()를 외부로 노출할 뿐이다. <br>
클라이언트가 제출한 자바 클래스의 byte[] 배열을 객체 클래스로 변환할 때 이 메서드를 이용할 것이다. <br>
가상 머신이 이 로더를 호출하면 부모 위임 모델에 따라 클래스 로딩은 상위 클래스로 위임될 것이다.

#### ClassModifier와 ByteUtils 클래스

ClassModifier 클래스는 자체 정의한 HackSystem 클래스로 java.lang.System을 대체하는 역할을 한다. <br>
클래스 파일 포맷을 준수하는 byte[] 배열의 상수 풀 부분을 직접 수정하고, 상수 풀에 지정된 내용의 C0NSTANT_Utf8_info 상수를 새로운 문자열로 대체한다. 

#### HackSystem 클래스

System을 대체하는 HackSystem이다. <br>
기본 System에서 달라지는 곳은 정적 변수 out과 err를 출력 대상이 ByteArrayOutputStream인 PrintStream 객체로 변경하는 부분 <br>
그리고 이 ByteArrayOutputStream의 내용을 읽고 정리하기 위해 getBufferString()과 clearBuffer() 메서드를 추가하는 정도다. <br>
나머지 메서드는 모두 System 클래스의 public 메서드를 그대로 가져온다.

#### JavaclassExecuter 클래스

앞에서 작성한 도우미 클래스들을 활용하여 클래스 로딩을 완료하는 클래스다. 메서드는 오직 하나, execute()뿐이다.














# 자바 메모리 영역과 메모리 오버플로

자바 개발자는 가상 머신이 제공하는 자동 메모리 관리 메커니즘 덕에 메모리 할당과 해제를 짝지어 코딩하지 않아도 메모리 누수나 오버플로 문제를 거의 겪지 않는다. <br>
하지만 통제권을 위임했기 때문에 생기는 단점도 있다. 문제가 한번 터지면 가상 머신의 메모리 관리 방식을 이해하지 못하는 한 해결하기가 상당히 어럽다는 점이다. <br>

## 런타임 데이터 영역

자바 가상 머신은 자바 프로그램을 실행하는 동안 필요한 메모리를 몇 개의 데이터 영역으로 나눠 관리한다. <br>
이 영역들은 각각목적과 생성/삭제 시점이 있다. <br>
어떤 영역은 가상 머신 프로세스의 시작과 동시에 만들어지며, 어떤 영역은 사용자 스레드의 시작/종료에 맞춰 생성/삭제된다.

<img width="562" alt="스크린샷 2024-12-29 오후 12 30 59" src="https://github.com/user-attachments/assets/aef61846-c013-42e1-912a-1a405422724d" />


### 프로그램 카운터

**프로그램 카운터 레지스터는 작은 메모리 영역**으로, 현재 실행 중인 스레드의 바이트코드 줄 번호 표시기라고 생각하면 쉽다. <br>
바이트코드 인터프리터는 이 카운터의 값을 바꿔 다음에 실행할 바이트코드 명령어를 선택하는 식으로 동작한다. <br>
프로그램의 제어 흐름, 분기, 순환, 점프 등을 표현하는 것이다. 예외 처리나 스레드 복원 같은 모든 기본 기능이 바로 이 표시기를 활용해 이루어진다.

자바 가상 머신에서의 멀티스레딩은 CPU 코어를 여러 스레드가 교대로 사용하는 방식으로 구현되기 때문에 특정 시각에 각 코어는 한 스레드의 명령어만 실행하게 된다. <br>
따라서 스레드 전환 후 이전에 실행하다 멈춘 지점을 정확하게 복원하려면 스레드 각각에는 고유한 프로그램 카운터가 필요하다. <br>
**각 스레드의 카운터는 서로 영향을 주지 않는 독립된 영역에 저장된다. 이 메모리 영역을 스레드 프라이빗 메모리라고 한다.**

### 자바 가상 머신 스택

자바 가상 머신 스택도 스레드 프라이빗하며, 연결된 스레드와 운명을 같이 한다. <br>
각 메서드가 호출될 때마다 자바 가상 머신은 스택 프레임을 만들어, 지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값 등의 정보를 저장한다. <br>
그런 다음 스택 프레임을 가상 머신 스택에 push하고, 메서드가 끝나면 pop하는 일을 반복한다.

**지역 변수 테이블에는 자바 가상 머신이 컴파일타임에 알 수 있는 다양한 기본 데이터 타입, 객체 참조, 반환 주소 타입을 저장한다.** <br>
지 역 변수 테이블을 구성하는 데 필요한 데이터 공간은 컴파일 과정에서 할당된다. 자바 메서드는 스택 프레임에서 지역 변수용으로 할당받아야 할 공간의 크기가 이미 완벽하게 결정되어 있다.

자바 가상 머신 명세는 스택 메모리 영 역에서 두 가지 오류가 발생할 수 있도록 정의했다.

1. 스레드가 요청한 스택 깊이가 가상 머신이 허용하는 깊이보다 크다면 StackOverflowError를 던진다.
2. 스택 용량을 동적으로 확장할 수 있는 자바 가상 머신에서는 스택을 확장하려는 시점에 여유 메모리가 충분하지 않다면 OutOfMemoryError를 던진다.

### 네이티브 메서드 스택

**네이티브 메서드 스택은 네이티브 메서드를 실행할 때 사용한다.** <br>
가상 머신 스택처럼 네이티브 메서드 스택도 스택 허용 깊이를 초과하면 StackOverflowError를, 스택 확장에 실패하면 OutOfMemoryError를 던질 수 있다.

### 자바 힙

자바 힙은 모든 스레드가 공유하며 가상 머신이 구동될 때 만들어진다. <br>
이 메모리 영역의 유일한 목적은 객체 인스턴스를 저장하는 것이고, 자바 세계의 거의 모든 객체 인스턴스가 이 영역에 할당된다. <br>
자바 힙은 물리적으로 떨어진 메모리에 위치해도 상관없으나 논리적으로는 연속되어야 한다. <br>
하지만 대다수 가상 머신이 큰 객체(배열 객체)는 물리적으로도 연속된 메모리 공간을 사용하도록 구현한다. 저장 효율을 높이고 구현 로직을 단순하게 유지하기 위해서다.


### 메서드 영역

메서드 영역도 자바 힙처럼 모든 스레드가 공유한다. <br>
메서드 영역은 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수 그리고 JIT 컴파일러가 컴파일한 코드 캐시등을 저장하는 데 이용된다.

자바 가상 머신 명세는 메서드 영역에 제약을 거의 두지 않았다. <br>
자바 힙과 마찬가지로 연속될 필요가 없으며, 크기를 고정할 수도 있고, 확장 가능하게 만들 수도 있다. 심지어 가비지 컬렉션을 하지 않아도 괜찮다. <br>
메서드 영역에서 회수할 대상은 거의 대부분 상수 풀과 타입이라서 회수 효과가 상대적으로 매우 작다. <br>
특히 타입은 회수할 수 있는 조건이 상당히 까다롭기까지 하다. 

### 런타임 상수 풀

런타임 상수 풀은 메서드 영역의 일부다. 상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 설명 정보에 더해 컴파일타임에 생성된 다양한 리터럴과 심벌 참조가 저장된다. <br>
자바 가상 머신은 클래스 파일의 각 영역별로 엄격한 규칙을 정해 놓았다. <br>
예컨대 가상 머신이 클래스 파일을 로드해 실행하려면 각 바이트에는 명세가 요구하는 데이터가 들어 있어야 한다. <br>
다만 런타임 상수 풀에 대해서는 요구 사항을 상세하게 정의하지 않아서 가상 머신 제공자가 입맛에 맞게 구현할 수 있다.

**클래스 파일의 상수 풀과 비교해 런타임 상수 풀의 중요한 특징이 하나 더 있다. 바로 동적이라는 점이다.** <br>
자바 언어에서는 상수가 꼭 컴파일타임에 생성되어야 한다는 규칙이 없다. <br>
런타임에도 메서드 영역의 런타임 상수 풀에 새로운 상수가 추가될 수 있다. <br>
개발자들이 많이 사용하는 String 클래스의 internO 메서드에 바로 이 특성이 반영되어 있다.

### 다이렉트 메모리

다이렉트 메모리는 가상 머신 런타임에 속하지 않으며 자바 가상 머신 명세에 정의된 영역도 아니다. <br>
하지만 자주 쓰이는 메모리이며 OutOfMemoryError의 원인이 될 수도 있다.

JDK 1.4에서 NIO가 도입되면서 채널과 버퍼 기반 I/O 메서드가 소개됐다. <br>
NIO는 힙이 아닌 메모리를 직접 할당할 수 있는 네이티브 함수 라이브러리를 이용하며, 이 메모리에 저장되어 있는 DirectByteBuffer 객체를 통해 작업을 수행할 수 있다. <br>
따라서 자바 힙과 네이티브 힙 사이에서 데이터를 복사해 주고받지 않아도 돼서 일부 시나리오에서 성능을 크게 개선했다.

<br>

## 핫스팟 가상 머신에서의 객체 들여다보기

### 객체 생성

자바 가상 머신이 new 명령에 해당하는 바이트코드를 만나면, 이 명령의 매개 변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인한다. <br>
그런 다음 이 심벌 참조가 뜻하는 클래스가 로딩, 해석, 초기화 되었는지 확인한다. <br>
로딩이 완료된 클래스라면 새 객체를 담을 메모리를 할당한다. <br>
객체에 필요한 메모리 크기는 클래스를 로딩하고 나면 완벽하게 알 수 있다. <br>
**객체용 메모리 공간 할당은 자바 힙에서 특정 크기의 메모리 블록을 잘라 주는 일이라 할 수 있다.**

자바 힙이 완벽히 규칙적이라고 가정하면 사용 중인 메모리는 모두 한쪽에, 여유 메모리는 반대편에 자리하며, <br>
포인터가 두 영역의 경계인 가운데 지점을 가리키게 될 것이다. 이 상태에서 메모리를 할당하면 포인터를 여유 공간 쪽으로, 정확히 객체 크기만큼 이동시키 게 된다.

<img width="582" alt="스크린샷 2024-12-29 오후 12 55 42" src="https://github.com/user-attachments/assets/1a1bd6cb-e1b8-4594-aa41-6a9bd050dbe3" />

> 하지만 자바 힙은 규칙적이지 않다. <br>
> 사용 중인 메모리와 여유 메모리가 뒤섞여 있어서 포인터를 밀쳐 내기가 그리 간단하지 않다. <br>
> 그 대신 가상 머신은 가용 메모리 블록들을 목록으로 따로 관리하며, 객체 인스턴스를 담기 에 충분한 공간을 찾아 할당한 후 목록을 갱신한다.


가상 머신에서 객체 생성은 매우 빈번히 일어난다. <br>
더욱이 멀티스레딩 환경에서는 여유 메모리의 시작 포인터 위치를 수정하는 단순한 일도 스레드 안전하지 않기 때문에 여러 스레드가 동시에 객체를 생성하려고 할 때 문제가 생길 수 있다. <br>
해법은 두 가지다. <br>

**첫 번째는 메모리 할당을 동기화하는 방법이다.** <br>
비교 및 교환(CAS)과 실패 시 재시도 방식의 가상 머신은 갱신을 원자적으로 수행한다.

**두 번째는 스레드마다 다른 메모리 공간을 할당하는 방법 이다.** <br>
스레드 각각이 자바 힙 내에 작은 크기의 전용 메모리를 미리 할당받아 놓는 것이다. 이런 메모리를 스레드 로컬 할당 버퍼라고 한다.

<br>


메모리 할당이 끝났으면 가상 머신은 할당받은 공간을 0으로 초기화한다. <br>
자바 코드에서 객체의 인스턴스 필드를 초기화하지 않고도 사용할 수 있는 이유가 바로 이 단계 덕이다. <br>
모든 필드가 자연스럽게 각 데이터 타입에 해당하는 0 값을 담고 있게 되는 것이다.

다음 단계로 자바 가상 머신은 각 객체에 필요한 설저을 해 준다. <br>
예를 들어 어느 클래스의 인스턴스인지, 클래스의 메타 정보는 어떻게 찾는지, 이 객체의 해시 코드는 무엇인지, GC 세대 나이는 얼마인지 등의 정보이다. <br>
**이런 정보가 각 객체의 객체 헤더에 저장된다.**

<br>

이상의 과정이 끝났다면 생성자(init) 메서드까지 실행되어 객체를 개발자의 의도대로 초기화해야 비로소 사용 가능한 진짜 객체가 완성된다. <br>

<img width="601" alt="스크린샷 2024-12-29 오후 1 03 47" src="https://github.com/user-attachments/assets/4a2ce8d8-d3ac-4072-bc2c-e7a664cf97c3" /> <br>
<img width="519" alt="스크린샷 2024-12-29 오후 1 03 50" src="https://github.com/user-attachments/assets/0e7ca32c-2ad9-4e88-8db8-6bb988eb4d95" />

### 객체의 메모리 레이아웃

핫스팟 가상 머신은 객체를 세 부분으로 나눠 힙에 저장한다. <br>
객체 헤더, 인스턴스 데이터, 길이 맞추기용 정렬 패딩이다.

<img width="609" alt="스크린샷 2024-12-29 오후 1 05 55" src="https://github.com/user-attachments/assets/2c8cb558-6a50-4c88-aee9-3a99810fa5ac" />

#### 객체 헤더

핫스팟 가상 머신은 객체 헤더에 두 유형의 정보를 담는다. <br>
**첫 번째 유형은 객체 자체의 런타임 데이터다.** <br>
해시 코드, GC 세대 나이, 락 상태 플래그, 스레드가 점유하고 있는 락들, 편향된 스레드의 아이디, 편향된 시각의 타임스탬프 등이다. (마크워드) <br>
**객체 헤더에서 마크 워드 다음에는 클래스 워드가 온다.** <br>
클래스 워드에는 객체의 클래스 관련 메타데이터를 가리키는 클래스 포인터가 저장된다. <br>
자바 가상 머신은 이 포인터를 통해 특정 객체가 어느 클래스의 인스턴스인지 런타임에 알 수 있다.

#### 인스턴스 데이터

인스턴스 데이터는 객체가 실제로 담고 있는 정보다. <br>
예컨대 프로그램 코드에서 정의한 다양한 타입의 필드 관련 내용, 부모 클래스 유무, 부모 클래스에서 정의한 모든 필드가 이 부분에 기록된다.

#### 정렬 패딩

이 부분은 존재하지 않을 수도 있으며, 특별한 의미 없이 자리를 확보하는 역할만 한다. <br>
핫스팟 가상 머신의 자동 메모리 관리 시스템에서 객체의 시작 주소는 반드시 8바이트의 정수배여야 한다. <br>
달리 말하면 모든 객체의 크기가 8바이트의 정수배여야 한다는 뜻이다. <br>
객체 헤더는 정확히 8바이트의 정수배가 되도록 잘 설계되어 있고, 인스턴스 데이터가 충족하지 못하는 경우에만 패딩으로 채운다.

### 객체에 접근하기

대다수 객체는 다른 객체 여러 개를 조합해 만들어진다. <br>
그리고 자바 프로그램은 스택에 있는 참조 데이터를 통해 힙에 들어 있는 객체들에 접근해 이를 조작한다. <br>
객체에 접근하는 방식 역시 가상 머신에서 구현하기 나름이며, 주로 핸들이나 다이렉트 포인터를 사용해 구현한다. 

**핸들 방식**에서는 자바 힙에 핸들 저장용 풀이 별도로 존재할 것이다. <br>
참조에는 객체의 핸들 주소가 저장되고 핸들에는 다시 해당 객체의 인스턴스 데이터, 타입 데이터, 구조 등의 정확한 주소 정보가 담길 것이다.

<img width="637" alt="스크린샷 2024-12-29 오후 1 12 33" src="https://github.com/user-attachments/assets/7d52572b-9398-4b09-ad64-466c0a4c1bb8" />

<br>

**다이렉트 포인터 방식**에서는 자바 힙에 위치한 객체에서 인스턴스 데이터뿐 아니라 타입 데이터에 접근하는 길도 제공해야 한다. <br>
다이렉트 포인터 방식의 가장 큰 장점은 속도다. 핸들을 경유하는 오버헤드가 없기 때문이다.

<img width="657" alt="스크린샷 2024-12-29 오후 1 13 54" src="https://github.com/user-attachments/assets/e7038ac4-6c8f-49f8-8624-e00bed8c88b5" />














# 자바 메모리 영역과 오버 플로우

자바 개발자는 기성 C/C++개발자에 비해 가상 머신이 제공하는 자동 메모리 관리 메커니즘 덕에 메모
리 할당과 해제를 짝지어 코딩하지 않아도 메모리 누수나 오버플로 문제를 거의 겪
지 않는다. 하지만 단점도 있는데,  문제가 한번 터지면 가상 머신의 메모리 관리 방식을 이해하지 못하는 한 해결하기가 상당히 어렵다는 점이다.

##  런타임 데이터 영역

![img01.png](img01.png)

### 프로그램 카운터

프로그램 카운터 레지스터는 작은 메모리 영역으로, 현재 실행 중인 스레드의 바이트코드 줄 번호 표시기'라고 생각하면 쉽다.

자바 가상 머신의 개념 모형에서 바이트코드 인터프리터는 이 카운터의 값을 바꿔 다음에 실행할 바이트코드 명령어를 선택하는 식으로 동작한다.

예외 처리나 스레드 복원 같은 모든 기본 기능이 바로 이 표시기를 통해 작동된다

자바 가상 머신에서의 멀티스레딩은 CPU 코어를 여러 스레드가 교대로 사용하는 방식으로 작동된다

따라서 특정 시각에 각 코어는 한 스레드의 명령어만 실행하게 된다.

스레드 전환 후 이전에 실행하다 멈춘 지점을 정확하게 복원하기 위해서 이 카운터가 필요한 것이다. 따라서 각 스레드의 카운터는 서로 영향을 주지 않는 독립된 영역에 저장된다.  이 메모리 영역을 스레드 프라이빗 메모리라고 한다.

스레드가 자바 메서드를 실행 중일 때는 실행 중인 바이트코드 명령어의 주소가 프로그램 카운터 에 기록된다. 스레드가 네이티브 메서드를 실행 중일 때 프로그램 카운터 값은 Undefined 이다.

프로그램 카운터 메모리 영역은 자바 가상 머신 명세에서 OutOfMemoryError 조건이 명시되지 않은 유일한 영역이기도하다.

### 자바 가상 머신 스택

프로그램 카운터처럼 자바 가상 머신 스택도 '스레드 프라이빗'하며, 연결된 스레드와 운명을 같이 한다.(생성/삭제 시기가 일치한다)

가상 머신 스택은 자바 메서드를 실행하는 스레드의 메모리 모델을 설명해 준다. 

각 메서드가 호출될 때마다 자바 가상 머신은 스택 프레임을 만들어 지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값 등의 정보를 저장한다.

자바에서 메모리영역을 힙 메모리와 스택 메모리로 구분하는 것은 C/C++프로그램의 메모리 구조에서 기인한 것으로 자바를 설명하기에 좋지 않다.

'스택'이라고 하면 보통 방 금 이야기한 자바 가상 머신 스택을 가리키는데, 그중 특히 지역 변수 테이블을 가리키곤 한다.

이 지역 변수 테이블에는 자바 가상 머신이 컴파일타임에 알 수 있는 다양한 기본 데이터 타입, 객체 참조, 반환 주소 타입을 저장한다.

지역 변수 테이블에서 데이터를 저장하는 공간을 슬롯(Slot)이라 한다. 일반적으로 슬롯의 크기는 32비트(4바이트)로 설정된다. 이에 따라, double 타입처럼 길이가 64비트인 데이터는 슬롯 두 개를 차지하며, 나머지 데이터 타입은 모두 슬롯 하나에 저장된다.

지역 변수 테이블의 크기와 구조는 자바 메서드가 실행되기 전에 컴파일 과정에서 이미 결정된다. 이는 메서드 실행 중 스택 프레임에서 사용될 지역 변수 공간을 확보하고, 할당된 크기를 변경하지 않도록 보장한다.


#### 슬롯 개수와 가상 머신 구현

가상 머신이 변수를 저장하는 데 사용하는 슬롯의 실제 크기와 메모리 사용 방식은 JVM 구현에 따라 달라질 수 있다. 예를 들어, 슬롯 크기가 32비트 또는 64비트 이상일 수 있다.

#### 스택 메모리에서 발생할 수 있는 오류

JVM 명세에서는 가상 머신 스택에서 다음 두 가지 주요 오류를 정의한다:
1.	StackOverflowError
스레드가 요청한 스택 깊이가 JVM이 허용하는 한도를 초과하면 발생한다.
2.	OutOfMemoryError
스택을 동적으로 확장할 수 있는 JVM에서 스택 확장을 시도했으나 메모리가 부족할 경우 발생한다.


### 네이티브 메서드 스택

네이티브 메서드 스택은 자바 가상 머신 스택과 매우 비슷한 역할을 한다. 차이점은 자바 가상 머신 스택이 자바 메서드(바이트코드)를 실행할 때 사용되는 반면, 네이티브 메서드 스택은 네이티브 메서드를 실행할 때 사용된다는 점이다.

자바 가상 머신 명세에서는 네이티브 메서드 스택이 어떤 구조로 구성되거나 어떻게 표현되어야 하는지에 대해 아무런 명시를 하지 않았다. 이로 인해 JVM 구현자들은 네이티브 메서드 스택을 자유롭게 설계할 수 있다. 가상 머신에 따라 네이티브 메서드 스택과 가상 머신 스택을 하나로 통합하는 구현도 존재한다(예: 핫스팟 가상 머신).

네이티브 메서드 스택도 자바 가상 머신 스택과 동일하게 스택 허용 깊이를 초과하면 StackOverflowError가 발생할 수 있으며, 스택 확장 과정에서 메모리가 부족한 경우 OutOfMemoryError가 발생할 수 있다.


### 자바 힙

자바 힙은 자바 애플리케이션이 사용할 수 있는 가장 큰 메모리 공간으로, 모든 스레드가 공유한다. 자바 힙은 자바 가상 머신이 구동될 때 만들어지며, 객체 인스턴스를 저장하는 것이 주요 목적이다. 자바 가상 머신 명세에서는 “모든 객체 인스턴스와 배열은 힙에 할당된다”고 명시하고 있다. 그러나 여기서 “거의”라는 표현을 사용하는 이유는 일부 객체가 힙이 아닌 다른 메모리 영역에 저장될 수도 있기 때문이다.

#### 자바 힙과 가비지 컬렉션

자바 힙은 가비지 컬렉터(GC)가 관리하는 메모리 영역으로, 메모리 회수와 할당 관점에서 최적화된 설계가 이루어졌다. 현대의 가비지 컬렉션은 주로 세대별 컬렉션 이론(Generational Collection Theory)을 기반으로 설계되었으며, 이에 따라 힙을 다음과 같은 영역으로 나누는 방식이 자주 사용된다:
- 신세대(Young Generation): 새로 생성된 객체가 저장되는 공간으로, 생존율이 낮은 객체를 빠르게 정리한다.
- 구세대(Old Generation): 오랜 기간 참조되거나 생존한 객체가 저장된다.
- 영구 세대(Permanent Generation) 또는 메타스페이스: 클래스와 메서드 메타데이터를 저장하는 영역.

#### JVM 구현에 따른 힙의 설계

JVM의 구현 방식에 따라 힙의 구조와 작동 방식은 다를 수 있다. 일부 JVM은 힙을 명시적으로 세분화하여 구세대와 신세대를 구분하지만, 최신 JVM에서는 힙을 이러한 전통적인 세대 구분 없이 사용하는 방식도 등장했다.

자바 힙은 논리적으로 연속된 메모리 공간으로 설계되지만, 물리적으로는 비연속적일 수 있다. 이는 디스크 파일을 저장할 때와 유사한 방식으로, 객체를 효율적으로 배치하고 접근 속도를 최적화하기 위함이다.

자바 힙의 크기는 고정되거나 동적으로 확장 가능한 형태로 설정할 수 있다. 예를 들어, -Xmx 및 -Xms 옵션을 통해 초기 힙 크기와 최대 크기를 지정할 수 있다. 만약 새로운 객체를 저장할 공간이 부족하거나 힙을 확장할 수 없는 경우, JVM은 OutOfMemoryError를 발생시킨다.

### 메서드 영역

메서드 영역은 자바 힙처럼 모든 스레드가 공유하며, 가상 머신이 읽어들인 타입 정보, 상수, 정적 변수, JIT 컴파일된 코드 캐시 등을 저장하는 데 사용된다. 자바 가상 머신 명세에서는 메서드 영역이 힙의 일부로 기술되기도 하지만, 이를 구분하기 위해 논힙(non-heap) 영역이라고 부르기도 한다.

특히 JDK 7까지는 메서드 영역이 영구 세대(PermGen)로 구현되었으며, 이는 많은 개발자들이 메서드 영역과 영구 세대를 혼동하게 만들었다. 당시 핫스팟 가상 머신의 가비지 컬렉터 수집 범위를 메서드 영역까지 확장하기 위해 영구 세대와 통합했기 때문이다. 이는 메서드 영역을 자바 힙처럼 가비지 컬렉션으로 관리할 수 있도록 하여 작업량을 줄이는 데 기여했다.

하지만 BEA의 JRockit이나 IBM의 J9와 같은 다른 JVM은 영구 세대 개념이 없었으며, 메서드 영역을 데이터 메모리로 구현하는 방식을 따랐다. JDK 8에서는 핫스팟 또한 영구 세대를 포기하고 메서드 영역을 메타스페이스(Metaspace)로 구현하여 기존의 메모리 제한을 크게 완화했다.

메타스페이스는 JVM 외부의 네이티브 메모리를 사용하므로 기본적으로 시스템 메모리에 의해 제약받으며, 이는 기존 영구 세대의 최대 크기를 제한했던 -XX:MaxPermSize 옵션과 달리 더욱 유연하다. 결과적으로, 메서드 영역의 크기와 성능은 JVM의 구현 방식에 따라 크게 달라질 수 있다. 예를 들어, 메서드 영역에서 문자열 상수를 관리하는 방식(String::intern())도 JVM에 따라 차이가 존재한다.

메서드 영역은 크기를 고정하거나 확장 가능한 형태로 설계될 수 있으며, 만약 필요한 메모리를 할당하지 못하면 OutOfMemoryError가 발생한다. 하지만 회수할 데이터가 대부분 상수 풀과 타입 정보로 구성되므로 가비지 컬렉션의 필요성은 상대적으로 적다. 이는 회수가 불필요하거나 드물게 이루어지는 데이터의 특성과 관련이 있다.

### 런타임 상수 풀

런타임 상수 풀은 메서드 영역의 일부로, 클래스 버전, 필드, 메서드, 인터페이스 등의 클래스 파일에 포함된 설명 정보에 대해 컴파일타임에 생성된 다양한 리터럴과 심볼 참조가 저장되는 공간이다. 자바 가상 머신은 클래스를 로드할 때 필요한 정보를 메서드 영역의 런타임 상수 풀에 저장한다.

자바 가상 머신은 클래스 파일의 각 영역별로 엄격한 규칙을 정해놓고, 실행 시 각 바이트코드에는 명세가 요구하는 데이터가 포함되어야 한다. 하지만 런타임 상수 풀의 내부 작동 방식에 대해서는 자바 가상 머신 명세에서 상세히 정의하지 않아, JVM 제공자가 구현 방식에 따라 자유롭게 설계할 수 있다. 일반적으로 클래스 파일에 기술된 심볼 참조는 런타임 상수 풀로 번역되어 저장된다.

런타임 상수 풀의 중요한 특징 중 하나는, 클래스 파일의 상수 풀과 비교해 런타임 상수 풀이 동적으로 동작할 수 있다는 점이다. 자바 언어에서는 상수가 꼭 컴파일타임에 생성되어야 한다는 규칙이 없기 때문에, 런타임 상수 풀에 새로운 상수가 추가될 수도 있다. 예를 들어, 개발자들이 자주 사용하는 String 클래스의 intern() 메서드는 런타임 상수 풀의 동적 성격을 반영한 대표적인 사례다.

### 다이렉트 메모리

다이렉트 메모리는 가상 머신 런타임에 속하지 않으며, 자바 가상 머신 명세에 정의된 영역도 아니다. 그러나 자주 사용되는 메모리로, OutOfMemoryError의 원인이 될 수 있어 중요한 메모리 영역으로 다뤄진다.

JDK 1.4에서 NIO(New Input/Output) API가 도입되면서 다이렉트 메모리는 채널과 버퍼 기반 I/O 메서드의 핵심적인 역할을 하게 되었다. NIO는 힙이 아닌 물리적 메모리를 직접 할당할 수 있는 네이티브 함수 라이브러리를 사용하며, 이를 통해 DirectByteBuffer 객체가 물리적 메모리에서 작업을 수행한다. 따라서 다이렉트 메모리를 사용하면 자바 힙과 네이티브 힙 사이에서 데이터를 복사하지 않아도 되므로 특정 작업 시 성능을 크게 개선할 수 있다.

다이렉트 메모리는 자바 힙 크기의 제한을 초월할 수 있지만, 시스템 메모리의 총 용량(물리적 메모리와 스왑 공간 포함)을 초과할 수는 없다. 예를 들어, 서버 관리자는 일반적으로 JVM의 힙 크기를 설정할 때 -Xmx 옵션으로 힙 크기를 제한한다. 그러나 다이렉트 메모리는 이와 별도로 네이티브 메모리를 사용하는 영역으로, 운영 체제의 메모리 한계(물리적 제약과 프로세스별 주소 공간)를 초과하면 OutOfMemoryError가 발생한다.

다이렉트 메모리는 자바 힙과 독립적으로 관리되며, 주로 대규모 데이터 전송이나 버퍼링 작업에서 효율성을 제공하기 위해 사용된다. 그러나 메모리 제한을 넘어서는 경우 문제가 발생할 수 있으므로 다이렉트 메모리의 사용량은 운영 환경에 따라 적절히 관리해야 한다.

## 핫스팟 가상 머신에서의 객체 들여다보기

### 객체 생성

자바는 객체 지향 프로그래밍 언어로, 객체는 프로그램 실행 중 언제든지 수시로 생성된다. 일반적으로 객체는 new 키워드를 통해 생성되며, 언어 차원에서는 매우 간단하게 보이지만 자바 가상 머신(JVM) 내부에서는 여러 단계의 복잡한 과정이 포함된다.

JVM이 new 명령어를 만나면, 해당 명령어가 참조하는 클래스가 이미 로드되어 초기화되었는지 확인한다. 클래스가 로드되지 않았다면 클래스 로딩 과정을 거치며, 이 과정을 통해 JVM은 클래스 정보를 메모리에 적재한다. 이후 새로운 객체를 생성할 메모리를 확보하는데, 이 과정에서 메모리의 크기는 클래스의 구조에 따라 결정된다.

객체 메모리 할당에는 주로 두 가지 방식이 사용된다. 

첫 번째는 포인터 밀기 방식(bump-the-pointer)으로, 메모리 공간이 연속적으로 배치된 경우 사용된다. 이 방식은 단순히 포인터를 이동시켜 공간을 할당하므로 매우 빠르다. 

두 번째는 여유 목록(free list) 방식으로, 사용 가능한 메모리 블록을 목록으로 관리하며 빈 공간을 찾아 객체를 할당한다. 이 방식은 메모리가 단편화되었을 때 유용하다.

객체가 메모리에 할당되면 JVM은 해당 객체에 필요한 메타데이터를 설정한다. 메타데이터에는 객체의 클래스 정보, GC 연령 정보, 메모리 크기 등이 포함된다. 이 정보는 객체의 헤더에 저장되며, 객체 관리 및 가비지 컬렉션에서 중요한 역할을 한다.

객체 생성 과정에서 마지막 단계는 객체 초기화이다. 생성자 메서드(<init> 메서드)가 호출되어 객체의 필드와 상태를 초기화하며, 이 과정이 끝나야 비로소 사용 가능한 객체가 생성된다. 일반적으로 생성자 호출은 JVM 바이트코드 명령어인 invokespecial을 통해 이루어진다.

JVM 내부에서 객체 생성은 최적화를 위해 다양한 알고리즘과 전략이 적용된다. 특히 가비지 컬렉션과 연계된 메모리 관리 방식을 통해 객체 생성 성능을 극대화하며, JIT 컴파일러는 실행 중에도 객체 생성 속도를 높이기 위한 최적화를 수행한다. 이러한 과정은 자바의 객체 지향적 특성을 유지하면서도 높은 성능을 제공하기 위해 설계되었다. 

## 객체의 메모리 레이아웃

핫스팟 가상 머신은 객체를 메모리에 저장할 때 객체 헤더, 인스턴스 데이터, 정렬 패딩의 세 부분으로 나누어 관리한다.

객체 헤더는 객체의 메타정보를 저장하는 부분으로, 다음과 같은 요소를 포함한다:
- 마크 워드(Mark Word): 객체의 해시 코드, GC 세대 나이, 잠금 정보 등의 런타임 데이터를 저장한다.
- 클래스 워드(Class Word): 객체의 클래스 메타데이터를 가리키는 포인터로, 해당 객체가 어떤 클래스에 속하는지 나타낸다.
- 배열 길이: 배열 객체인 경우, 배열의 길이를 저장한다. 일반 객체에서는 이 필드는 존재하지 않는다.

인스턴스 데이터는 객체가 실제로 담고 있는 필드 값(상속된 필드 포함)들을 저장하는 공간이다. 클래스의 정의에 따라 이 공간의 크기와 구조가 결정된다.

정렬 패딩(Alignment Padding)은 메모리 정렬을 위해 추가되는 공간으로, 객체의 전체 크기를 8바이트의 배수로 맞추기 위해 사용된다. 이는 CPU의 메모리 접근 성능을 최적화하기 위한 조치이다.

객체 헤더는 메타스페이스에 저장된 클래스 메타데이터와 연결되어 있으며, 이를 통해 객체의 클래스 정보를 확인할 수 있다. 이 구조는 객체가 자바 힙에 효율적으로 저장되도록 설계되었으며, JVM이 객체를 관리하고 가비지 컬렉션을 수행하는 데 중요한 역할을 한다.

### 객체 헤더

핫스팟 가상 머신에서 객체 헤더는 두 가지 주요 정보를 담는다. 첫 번째는 객체 자체의 런타임 데이터이고, 두 번째는 객체의 클래스 메타데이터를 가리키는 포인터다.

#### 객체 헤더의 마크 워드(Mark Word)에 속하는 정보
- 객체의 해시 코드
- GC 세대 나이
- 락 상태 플래그
- 스레드가 점유하고 있는 락 정보
- 편향된 스레드의 ID 및 타임스탬프 등

마크 워드는 동적으로 재사용되며, 객체 상태에 따라 다양한 데이터를 담는다. 예를 들어, 32비트 가상 머신에서는 마크 워드가 32비트를 차지하고, 그중 일부는 객체의 해시 코드와 GC 관련 데이터를 저장하는 데 사용된다. 64비트 가상 머신에서는 마크 워드 크기가 64비트로 확장된다.

마크 워드 다음에는 클래스 워드(Class Word)가 위치한다. 클래스 워드는 객체가 속한 클래스의 메타데이터를 가리키는 포인터로, 객체의 구조와 동작을 정의하는 데 사용된다. 또한, 배열 객체의 경우 객체 헤더에 배열 길이 필드가 추가된다. 이 필드는 배열의 원소 개수를 저장하며, 배열 객체의 크기를 계산하는 데 필요하다.

객체 헤더의 설계는 메모리 효율성을 극대화하기 위해 최적화되어 있으며, 객체의 상태와 사용 패턴에 따라 정보를 동적으로 변경한다. 예를 들어, 객체가 락에 걸리지 않은 상태에서는 마크 워드에 해시 코드와 GC 관련 정보가 저장되고, 락이 활성화되면 락 정보를 저장하는 방식으로 활용된다.

핫스팟 JVM에서는 객체 헤더의 구조가 운영 환경(32비트 또는 64비트), GC 전략, 그리고 동시성 제어 방식에 따라 달라질 수 있다. 객체 헤더는 메모리 공간의 효율성을 유지하면서도, 객체의 상태를 추적하고 관리하기 위한 중요한 역할을 한다.

### 인스턴스 데이터

인스턴스 데이터는 객체가 실제로 담고 있는 정보를 저장하는 영역으로, 클래스에서 정의한 필드와 부모 클래스에서 상속된 필드가 포함된다. 저장 순서는 JVM의 할당 전략(-XX:FieldsAllocationStyle)과 필드 정의 순서에 따라 달라진다.

핫스팟 JVM은 기본적으로 long, double, int, short, char, byte, boolean, 객체 포인터 순서로 필드를 정렬한다. 길이가 같은 필드는 함께 배치되고, 부모 클래스의 필드는 자식 클래스 필드보다 앞에 저장된다.

-XX:CompactFields 옵션이 활성화되면(기본값 true) 짧은 길이의 필드는 상위 클래스의 변수 사이에 끼워 넣어 메모리 사용을 최적화한다. 이를 통해 객체 메모리 크기를 줄이고 공간 효율성을 높일 수 있다.

### 정렬 패딩

정렬 패딩은 객체 메모리의 마지막 부분에 위치하며, 메모리 정렬을 위해 추가되는 공간이다. 이 부분은 특정 조건에서만 존재하며, 의미 있는 데이터를 저장하지 않고 단순히 공간을 확보하는 역할을 한다.

핫스팟 JVM의 메모리 관리 시스템은 객체의 시작 주소가 반드시 8바이트의 정수 배수로 정렬되도록 설계되어 있다. 이는 CPU의 메모리 접근 효율성을 높이기 위함이다. 따라서 객체 크기가 8바이트의 배수가 되지 않을 경우, 부족한 공간을 패딩으로 채워 메모리를 정렬한다.

정렬 패딩은 객체의 인스턴스 데이터가 조건을 충족하지 못할 때만 추가되며, 1배 혹은 2배 크기의 패딩이 사용될 수 있다. 결과적으로, 정렬 패딩은 객체 메모리의 크기를 조정하여 메모리 접근 성능을 최적화하는 중요한 역할을 한다.

#### 객체 접근하기

자바에서 객체는 스택의 참조 변수를 통해 힙에 있는 데이터에 접근한다. 객체 접근 방식은 가상 머신 구현에 따라 다를 수 있으며, 주로 핸들 방식과 다이렉트 포인터 방식이 사용된다.

핸들 방식은 자바 힙 내에 별도의 핸들 저장소를 두고, 스택의 참조 변수는 핸들의 주소를 저장한다. 핸들은 다시 객체 인스턴스 데이터와 객체 타입 데이터의 정확한 주소를 가리킨다. 이 방식은 객체의 위치가 이동하더라도 핸들의 주소는 고정되므로 안정적이다. 객체 이동이 잦은 환경에서 유리하지만, 핸들을 관리하는 오버헤드가 발생한다.

다이렉트 포인터 방식은 참조 변수가 객체의 실제 주소를 직접 저장한다. 이 방식은 핸들 관리 오버헤드가 없고 접근 속도가 빠르다. 핫스팟 JVM은 주로 다이렉트 포인터 방식을 사용한다. 하지만 객체의 위치가 바뀌면 참조 변수의 값을 업데이트해야 하므로, 가비지 컬렉션 중 객체 이동이 적은 환경에서 적합하다.

핸들 방식은 안정성에서, 다이렉트 포인터 방식은 속도에서 장점이 있으며, 각 방식은 JVM의 목적과 설계에 따라 선택적으로 사용된다. 핸들은 다양한 언어나 프레임워크에서 활용되는 보편적인 기법이다.

### OutOfMemoryError 예외

OutOfMemoryError는 자바 가상 머신 메모리의 특정 영역에서 메모리를 할당하지 못할 때 발생한다. 이 예외는 힙 메모리, 메서드 영역, 스택 등 다양한 영역에서 발생할 수 있으며, 각 영역별로 원인을 파악하고 적절히 대응하는 것이 중요하다.

실제 예외 상황을 실험하려면 VM 매개 변수를 활용해 메모리 설정을 조정해야 한다. 예를 들어, 힙 메모리 용량을 -Xms20m과 -Xmx20m으로 제한하고, -XX:+HeapDumpOnOutOfMemoryError 옵션을 추가하면, 메모리가 부족한 시점에 힙 덤프를 생성해 문제를 분석할 수 있다.

OpenJDK 17의 핫스팟 가상 머신을 기준으로 테스트를 진행할 경우, 설정과 결과는 JVM의 구현 방식에 따라 달라질 수 있다. 따라서 다른 버전이나 JVM 공급업체의 환경에서는 설정과 동작 방식이 다를 수 있음을 염두에 둬야 한다.

### 자바 힙 오버플로

자바 힙은 객체 인스턴스를 저장하는 공간으로, 객체를 계속 생성하다 보면 힙의 최대 용량을 초과하여 OutOfMemoryError가 발생할 수 있다. 이를 방지하거나 문제를 분석하기 위해 힙 크기를 제한하고, 예외 발생 시 힙 덤프를 생성하는 설정을 활용할 수 있다.

예를 들어, 힙 크기를 -Xms20m과 -Xmx20m으로 설정하면 힙의 최소 크기와 최대 크기를 동일하게 제한할 수 있다. 또한 -XX:+HeapDumpOnOutOfMemoryError 옵션을 사용하면 메모리 부족 시점의 힙 스냅샷을 생성하여 저장한다. 이를 통해 예외 발생 원인을 분석할 수 있다.

힙 덤프 파일은 메모리 누수나 불필요한 객체가 메모리를 차지하고 있는지를 확인하는 데 유용하다. 이클립스 메모리 분석기(Eclipse Memory Analyzer) 같은 도구를 사용하면, 누적된 객체의 참조 경로나 GC 루트 정보를 시각적으로 분석할 수 있다. 이를 통해 불필요한 객체를 식별하고 제거하거나, 코드 구조를 최적화하여 메모리 사용량을 줄일 수 있다.

메모리 누수가 아닌 경우, 프로그램이 필요 이상으로 많은 메모리를 사용하는지 점검해야 한다. 필요 이상의 객체를 생성하거나 과도한 데이터 구조를 사용하는 코드를 수정하여 메모리 효율성을 높이는 것이 중요하다.

### 가상 머신 스택과 네이티브 메서드 스택 오버플로

자바 가상 머신 스택은 가상 머신 스택과 네이티브 메서드 스택을 구분하지 않고 동일한 메커니즘으로 동작한다. 스택 크기는 -Xss 옵션으로 조정할 수 있으며, 스택 오버플로는 다음 두 가지 경우에 발생할 수 있다.
1. 스택 깊이가 최대 허용치를 초과
스레드가 요구하는 스택 깊이가 자바 가상 머신에서 허용하는 최대 깊이를 초과하면 StackOverflowError가 발생한다. 이는 주로 재귀 호출이 너무 깊거나 지역 변수가 과도하게 선언된 경우 발생한다. 예를 들어, 재귀 호출이 중첩될수록 스택 프레임을 계속 추가하게 되어 스택이 가득 찬다.

2. 동적 스택 확장 실패
일부 JVM 구현은 스택을 동적으로 확장할 수 있는 메커니즘을 제공한다. 그러나 JVM이 동적 확장을 지원하지 않거나 메모리가 부족해 스택 크기를 확장할 수 없는 경우, OutOfMemoryError가 발생한다.

스택 오버플로와 관련된 실습 개념 요약
- 스택 깊이 제한 실험
 - - 작은 크기의 스택을 설정(-Xss180k)하고 무한 재귀 호출을 실행하면, 스택이 고갈되어 StackOverflowError가 발생한다. 출력 메시지는 호출된 스택 깊이(프레임 개수)를 보여준다.
- 지역 변수 테이블의 크기 실험
 - - 메서드 프레임의 지역 변수 테이블 크기를 과도하게 늘리면, 테이블 크기로 인해 스택이 빠르게 소진되면서 StackOverflowError가 발생한다.

#### 스레드 생성과 메모리 오버플로

다수의 스레드를 생성하면 시스템 메모리가 부족하거나 운영체제의 한계에 도달하여 더 이상 스레드를 생성할 수 없게 된다. 이 경우 OutOfMemoryError 또는 “unable to create native thread” 메시지가 나타난다. 이는 스레드 생성에 필요한 스택 메모리와 운영체제의 자원 제한 때문이다.

#### 해결 방안
- 스택 크기를 적절히 설정하여 스택 깊이를 제한한다.
- 메모리 자원을 효율적으로 사용하기 위해 스레드 수를 줄인다.
- 스택 크기를 동적으로 확장할 수 있는 환경을 조성하거나, 필요에 따라 힙 메모리 크기와 스택 크기 간의 균형을 조정한다.

### 메서드 영역과 런타임 상수 풀 오버플로

메서드 영역과 런타임 상수 풀 오버플로는 메서드 영역에 속하는 문제이며, 두 영역 모두 메모리 관리와 관련된 오류를 일으킬 수 있는 영역이다. JDK 6까지는 메서드 영역이 영구 세대(PermGen)에 구현되어 있었으며, JDK 7 이후에는 메타스페이스로 완전히 대체되었다.

런타임 상수 풀은 String 클래스의 intern() 메서드를 통해 사용되며, 이 메서드는 상수 풀에 이미 존재하는 문자열을 참조로 반환하거나 새롭게 상수 풀에 추가한다. JDK 6에서는 런타임 상수 풀이 영구 세대에 위치했으나, JDK 7 이상에서는 힙 영역으로 이동하여 메서드 영역 제한과 무관하게 동작하게 되었다.

#### 오버플로의 원인
1. JDK 6 이하에서는 영구 세대의 크기가 제한적이기 때문에 메모리 부족 시 PermGen space 오류가 발생하게 된다.
2. JDK 7 이상에서는 상수 풀이 힙 영역으로 이동했기 때문에, 힙 크기 제한에 따라 메모리 부족 여부가 결정된다.

#### 메서드 영역의 역할

메서드 영역은 클래스 이름, 접근 제한자, 상수 풀, 필드 설명, 메서드와 같은 데이터를 저장하는 공간이다. 또한 동적 언어나 프레임워크가 사용하는 동적 클래스 생성과 관련하여 자주 활용된다. 동적 클래스 생성 시에는 메서드 영역의 메모리 사용량이 크게 증가하기 때문에 세심한 관리가 필요하다.

#### JDK 8 이후 메타스페이스

JDK 8부터 메타스페이스는 네이티브 메모리 영역으로 이동되었으며, 기본 설정에서는 메서드 영역 오버플로가 발생하기 어렵지만, 특정 설정(-XX:MaxMetaspaceSize)에 따라 영향을 받을 수 있다. 주요 설정은 다음과 같다:
- -XX:MaxMetaspaceSize는 메타스페이스의 최대 크기를 설정하는 옵션이다.
- -XX:MetaspaceSize는 메타스페이스의 초기 크기를 설정하는 옵션이다.
- -XX:MinMetaspaceFreeRatio는 가비지 컬렉션 이후의 메타스페이스 여유 공간 비율을 설정하는 옵션이다.

#### 동적 클래스 생성

동적 언어나 프레임워크에서는 메서드 영역을 자주 사용하며, JSP 컴파일 시 클래스 파일 생성이나 CGLib를 사용한 프록시 클래스 생성이 대표적인 사례이다. 이러한 작업이 빈번히 발생하면 메서드 영역의 메모리 사용량이 크게 증가할 수 있으며, 이를 방지하기 위한 적절한 메모리 관리가 필요하다.

이러한 개념은 메모리 최적화와 애플리케이션의 안정성을 확보하기 위해 반드시 이해해야 하는 부분이다.

### 네이티브 다이렉트 메모리 오버플로 

네이티브 다이렉트 메모리 오버플로는 자바 가상 머신에서 다이렉트 메모리를 사용하는 과정에서 발생할 수 있는 메모리 오버플로 상황을 말한다. 다이렉트 메모리는 JVM 힙 메모리와는 독립적인 네이티브 메모리 영역에 할당되는 메모리이다. 이 영역의 용량은 -XX:MaxDirectMemorySize 옵션을 통해 설정할 수 있으며, 해당 값을 명시하지 않으면 기본적으로 -Xmx로 설정한 최대 힙 크기와 동일한 크기로 설정된다.

DirectByteBuffer 클래스는 다이렉트 메모리를 활용하기 위해 사용되는 주요 클래스이다. 내부적으로 Unsafe 클래스를 사용하여 네이티브 메모리에 접근하고 메모리를 할당한다. Unsafe 클래스는 자바 표준 API에는 포함되지 않지만, 리플렉션을 통해 인스턴스를 생성하여 사용할 수 있다. 이 클래스의 allocateMemory 메서드를 이용하면 다이렉트 메모리를 할당할 수 있는데, 메모리 사용량이 MaxDirectMemorySize 한계를 초과하면 메모리 오버플로가 발생할 수 있다.

네이티브 다이렉트 메모리 오버플로의 원인을 분석하기 위해 메모리 덤프를 확인하는 것이 중요하다. 메모리 덤프를 분석하여 다이렉트 메모리에서 실제로 사용된 크기와 초과된 원인을 파악할 수 있다. 예를 들어, 프로그램이 DirectMemory를 직접적으로 또는 간접적으로 사용했는지를 확인하고, MaxDirectMemorySize 설정을 통해 제한이 적절했는지를 점검해야 한다.

다이렉트 메모리 오버플로를 방지하기 위해서는 다음과 같은 조치가 필요하다:
- -XX:MaxDirectMemorySize 값을 명시적으로 설정하여 사용할 수 있는 다이렉트 메모리 용량을 제한해야 한다.
- 다이렉트 메모리를 사용하는 코드의 메모리 할당 로직을 최적화하거나, 필요 시 메모리 회수(garbage collection)가 제대로 이루어지도록 해야 한다.
- 자바 가상 머신 외부에서 사용하는 네이티브 라이브러리가 다이렉트 메모리를 과도하게 사용하는 경우, 해당 라이브러리의 설정을 조정해야 한다.
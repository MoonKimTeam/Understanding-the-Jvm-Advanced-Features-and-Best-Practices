# 자바 메모리 모델과 스레드

자바 언어와 가상 머신은 동시성 프로그래밍의 어려움을 상당히 낮춰주는 도구를 많이 제공한다. <br>
다양한 미들웨어와 프레임워크 또한 개발자가 비즈니스 로직에 집중할 수 있도록 동시성과 관련된 복잡한 내용을 최대한 숨겨 준다. <br>
얼마나 많은 사람이 서비스를 동시에 호출할 수 있는지, 데이터 경합은 어떻게 처리할지，하드웨어 자원은 어떻게 분배해 사용할지 등에 신경 쓰지 않도록 해 준다. <br>

## 하드웨어에서의 효율과 일관성

프로세서는 데이터를 읽고 작업 결과를 저장해야 하므로 적어도 메모리는 반드시 필요하다. <br>
메모리 I/O는 없애기가 매우 어렵다. 모든 컴퓨팅 작업을 레지스터만 사용해 완료하기는 어렵다. <br>
그런데 메모리는 프로세서에 비해 속도가 너무 느리기 때문에 현대적인 컴퓨터에서는 둘 사이에 캐시 계층을 하나 이상 둔다. <br>
필요한 데이터를 캐시에 복사해 두어 작업을 빠르게 수행하고, 작업이 완료되면 결과 데이터를 캐시에서 메모리로 동기화한다. <br>
이처럼 캐시를 활용하면 프로세서와 메모리 속도의 격차 문제가 원만하게 해결된다. <br>
하지만 컴퓨터 시스템이 그만큼 복잡해져서 캐시 일관성이라는 새로운 문제를 낳는다.

<img width="475" alt="Image" src="https://github.com/user-attachments/assets/60403ca8-ccc8-44ee-a693-4fd0cd50c8a2" />

> 멀티프로세서 시스템에서는 프로세서 각각이 자신만의 캐시를 갖춘 채 똑같은 메인 메모리를 공유한다. (공유 메모리 멀티프로세스 시스템) <br>
> 여러 프로세서가 메인 메모리의 같은 영역을 보며 작업하더라도 프로세서별 캐시 데이터는 서로 다를 수 있다. 이 경우 데이터를 메인 메모리로 동기화할 때 어느 프로세서의 데이터를 기준으로 삼아야 할까? <br>
> 일관성 문제를 해결하려면 프로세서가 캐시를 이용할 때 정해진 프로토콜을 따라야 한다. (MSI, MESI, MOSI 등) <br>

## 자바 메모리 모델

### 메인 메모리와 작업 메모리

자바 메모리 모델의 주된 목적은 프로그램에서 다양한 변수에 접근하는 규칙을 정하는 것이다. <br>
여기서 말하는 변수는 자바 프로그래밍 에서 말하는 변수와 다르다. 지금 말하는 변수에는 인스턴스 필드, 정적 필드, 배열 객체의 원소는 포함되지만 지 역 변수와 메서드 매개 변수는 포함되지 않는다. <br>
후자는 스레드별 고유 공간을 활용하므로 다른 스레드와 경합하지 않기 때문이다. <br>

<img width="478" alt="Image" src="https://github.com/user-attachments/assets/7ff7a295-922c-482a-84da-0c55e583327d" />

자바 메모리 모델은 모든 변수가 메인 메모리에 저장된다고 규정한다. 여기서 메인 메모리는 물리적인 메인 메모리가 아니라 가상 머신이 관리하는 메모리를 말한다. <br>
그리고 각 스레드는 자체 작업 메모리를 갖는다. 작업 메모리는 프로세스의 캐시와 비슷한 역할을 한다. 작업 메모리에는 해당 스레드가 사용하는 변수가 저장된 메인 메모리의 복사본이 담겨 있다. <br>
스레드가 변수를 읽고 쓰는 모든 연산은 작업 메모리에서 수행되며, 메인 메모리의 데이터는 직접 읽고 쓸 수 없다. <br>
또한 스레드끼리는 서로의 작업 메모리에 있는 변수에 직접 접근할 수 없다. 반드시 메인 메모리를 거쳐 값을 전송해야 한다.

### 메모리 간 상호작용

메인 메모리와 작업 메모리 사이의 프로토콜, 즉 메인 메모리에서 작업 메모리로 변수를 복사하고 작업 메모리의 내용을 메인 메모리로 다시 동기화하는 구체적인 방법을 자바 메모리 모델은 다음과 같이 여덟 가지로 정의했다. <br>
자바 가상 머신은 각 단계의 연산이 원자적으로 이루어지도록 보장해야 한다.

- 잠금: 메인 메모리에 존재하는 변수를 특정 스레드만 사용할 수 있는 상태로 만든다.
- 잠금 해제: 잠겨 있는 변수를 잠금 해제한다. 잠금이 해제된 변수는 다른 스레드에 의해 잠길 수 있다.
- 읽기: 뒤이어 수행되는 적재 연산을 위해 메인 메모리의 변숫값을 특정 스레드의 작업 메모리로 전송한다.
- 적재: 읽기 연산으로 메인 메모리에서 얻은 값을 작업 메모리의 변수에 복사해 넣는다.
- 사용: 작업 메모리의 변숫값을 실행 엔진으로 전달한다. 가상 머신이 변숫값을 사용하는 바이트코드 명령어를 만날 때마다 실행된다
- 할당: 실행 엔진에서 받은 값을 작업 메모리의 변수에 할당한다. 가상 머신이 변수에 값을 할당하는 바이트코드 명령어를 만날 때마다 실행된다.
- 저장: 뒤이어 수행되는 쓰기 연산을 위해 작업 메모리의 변숫값을 메인 메모리로 전송한다.
- 쓰기: 저장 연산으로 작업 메모리에서 얻어온 값을 메인 메모리의 변수에 기록한다.

### volatile 변수용 특별 규칙

volatile 키워드는 자바 가상 머신이 제공하는 가장 가벼운 동기화 메커니즘이다. <br>
하지만 완벽하게 이해하기는 쉽지 않아서 스레드들이 데이터를 놓고 경합할 때 volatile 대신 synchronized를 주로 활용하는 개발자가 많다. <br>
변수가 volatile로 정의 되면 두 가지 특성을 갖게 된다.

첫째, 모든 스레드에서 이 변수를 투명하게 볼 수 있다. (가시성을 보장한다.) <br>
한 스레드가 값을 수정하면 다른 스레드들도 새로운 값을 즉시 알게 된다는 뜻이다. 일반 변수는 이런 특성을 보장받지 못한다. <br>
일반 변수는 값이 메인 메모리를 거쳐 전달된다. 예를 들어 스레드 A가 수정한 공유 변수의 값을 스레드 B가 확인하려면, <br>
먼저 A가 수정된 값을 메인 메모리에 기록(write back)한 다음 B가 메인 메모리를 다시 읽어 와야 한다. <br>
그래서 많은 개발자가 volatile 변수를 다음과 같이 오해하고 있다.

> volatile 변수는 모든 스레드에서 즉시 볼 수 있으며, volatile 변수에 가해지는 모든 쓰기는 즉시 다른 스레드들에 반영된다. <br>
> 다시 말해 volatile 변수의 값은 모든 스레드에서 일관되므로 volatile 변수를 사용한 작업은 동시성 환경에서 안전하다.

**volatile 변수를 사용한 작업은 동시성 환경에서 안전하다 라는 결론은 과장이다.** <br>
각 스레드의 작업 메모리에서는 volatile 변수의 일관성에 문제가 없다. <br>
하지만 자바의 산술 연산자가 원자적이 아니라서 volatile 변수라도 멀티스레드 환경에서 완벽하게 안전하지는 못하다.

<img width="484" alt="Image" src="https://github.com/user-attachments/assets/ce7597a9-811a-433f-814a-c302af1700e5" />

스레드들이 모두 올바르게 실행되면 최종 출력은 200,000이어야 한다. <br>
하지만 실행해보면 매번 결과가 다르고 200,000보다 작은 값이 출력된다. <br>
문제는 race++에 있는데, 이 코드를 javap로 디컴파일하면 바이트코드에서는 명령어 4개로 구성된다.

```java
public static void increase();
    Code:
        stack=2, locals=0, args_size=0
            0: getstatic #7 // Field race:I
            3: iconst_1
            4: iadd
            5: putstatic #7 // Field race:I
            8: return
        LineNumberTable:
            line 11: 0
            line 12: 8
```

> getstatic 명령어가 race 값을 피연산자 스택에서 가져올 때 volatile 키워드 때문에 race 값이 올바른지 확인하게 된다. <br>
> 하지만 iconst_1과 iadd등의 명령어를 실행하는 동안 다른 스레드가 race 값을 변경하면 피연산자 스택의 race 값은 변경 전 값이 된다. <br>
> 따라서 putstatic 명령어가 실행될때는 이전 값에 기반한 계산 결과를 메인 메모리에 동기화하는 일이 벌어질 수 있다.

volatile 변수는 가시성만 보장하기 때문에 다음 두 규칙을 충족하지 못하는 시나리오에서는 락을 활용하여 원자성을 보장해야 한다. <br>

- 연산 결과가 변수의 현재 값과 무관하거나 변수의 값을 수정하는 스레드가 하나뿐임을 보장한다.
- 다른 상태 변수와 관련한 불변성 제약 조건에 관여하지 않는다.

<br>

volatile로 선언한 변수의 두 번째 특성은 명령어 재정렬 최적화를 막아 준다는 것이다. <br>
일반 변수는 메서드 실행 중 할당 결과를 이용해야 하는 모든 위치에서 올바른 결과를 얻는다는 점만 보장될 뿐, 변수 할당 작업의 실행 순서가 프로그램 코드 순서와 같다는 보장은 없다. <br>
이 러한 명령어 재정 렬은 같은 스레드에서 메서드를 실행하는 동안에는 탐지할 수 없다.

```java
Map configOptions;
char[] configText;
// 이 변수는 반드시 volatile로 선언한다.
volatile boolean initialized = false;

// 다음 코드가 스레드 A에서 실행된다고 가정
// 설정 정보 읽기 시뮬레이션
// - 읽기가 완료되면, initialized 변수를 true로 설정하여 '설정을 읽어 가도 좋다'라고 다른 스레드들에 통보한다.
configOption = new HashMap();
configText = readConfigFile(fileName);
processConfigOptions(configText, configOptions);
initialized = true;

// 다음 코드가 스레드 B에서 실행된다고 가정하자.
// initialized가 true가 될 때까지, 즉 스레드 A가 설정 초기화를 마칠 때까지 기다린다.
while (!initialized) {
    sleep();
}
// 스레드 A가 초기화한 설정 정보를 이용한다.
doSomethingWithConfig();
```

명령어 재정렬이 이루어지면 스레드 A의 마지막 코드 initialized = true가 조기 실행되도록 하여 이 변수를 사용하는 스레드 B의 코드에서는 오류가 날 수 있다. <br>
하지만 volatile 키워드가 이 상황을 막아준다.

### long과 double 변수용 특별 규칙

자바 메모리 모델에서는 잠금, 잠금 해제, 알기, 적재, 할당, 사용, 저장, 쓰기 연산이 모두 원자적이어야 한다. <br>
하지만 64비트 데이터 타입인 long과 double에는 좀 더 느슨한 특별 규칙이 적용된다. <br>
가상 머신은 volatile로 지정되지 않은 64비트 데이터의 읽기와 쓰기는 32비트 연산 2개로 나눠 처리할 수 있다. <br>
즉, 64비트 데이터의 적재, 저장, 읽기, 쓰기 연산의 원자성을 보장할지 여부를 가상 머신이 선택할 수 있다.

### 선 발생 원칙

자바 메모리 모델에서 모든 실행 순서를 volatile과 synchronized로만 처리한다면 많은 연산이 매우 장황해진다. <br>
하지만 자바는 선 발생 원칙을 따르기 때문에 동시성 코드를 작성할 때 이런 장황함을 인식하지 못한다. <br>
선 발생 원칙은 데이터 경합 발생 여부와 스레드 안전성을 확인하는 데 매우 유용한 수단이다.

**선 발생 원칙이란, 자바 메모리 모델에서 정의된 두 작업의 수행 순서 관계를 말한다.** <br>
예를 들어 작업 A는 작업 B보다 선 발생한다 라고 하면, 작업 B가 수행되기 전에 작업 A의 영향을 작업 B에서 관찰할 수 있다는 뜻이다. <br>
이때 영향이란 공유 변수의 값 변경, 메시지 전송, 메서드 호출 등을 모두 포함한다.

한편 두 작업 사이의 관계가 없고, 목록으로부터 추론할 수도 없다면 실행 순서가 보장되지 않는다. (가상 머신이 마음대로 순서를 바꿀 수 있다.)

## 자바와 스레드

자바에서 동시성은 기본적으로 스레드와 분리해 이야기할 수 없다.

### 스레드 구현

스레드는 프로세스보다 가벼운 스케줄링 단위다. 자원 할당과 실행 스케줄링 측면에서 스레드와 프로세스는 차이가 있다. <br.
스레드 각각은 프로세스 자원을 공유할 수 있으며 독립적으로 스케줄링된다. <br>
JDK 20까지는 자바에서는 스레드가 프로세서 자원 스케줄링의 최소 단위다. <br>
하지만 JDK 21에 와서는 가상 사르데를 도입해 상황이 달라졌다.

Thread 클래스는 대부분의 다른 자바 클래스 라이브러리 API와 이질적이고, 핵심 메서드 모두가 네이티브 코드로 구현되었다. <br>
네이티브 메서드로 구현한 이유는 물론 실행 효율 때문일 수도 있지만, 플랫폼 독립적 수단만으로는 구현할 수 없어서 인 경우도 있다. <br>
스레드 구현 방법은 크게 3가지다.

1. 커널 스레드 구현 (1:1 구현)
2. 사용자 스레드 구현 (1:N 구현)
3. 사용자 스레드와 경량 프로세스의 하이브리드 구현 (M:N 구현)

#### 커널 스레드 구현

커널 스레드는 운영 체제 커널에서 직접 지원하는 스레드이며, 스레드의 작업을 각 프로세스에 매핑하는 역할을 한다. <br>
프로그램은 일반적으로 커널 스레드를 직접 사용하지 않고, 그 대신 커널 스레드의 고수준 인터페이스인 경량 프로세스를 이용한다. <br>
경량 프로세스 각각은 커널 스레드의 도움을 받기 때문에 커널 스레드가 먼저 지원되어야 경량 프로세스도 존재할 수 있다. 경량 프로세스와 커널 스레드 사이의 1:1 관계를 일대일 스레딩 모델이라 한다.

<img width="597" alt="Image" src="https://github.com/user-attachments/assets/bced74dc-f58b-4859-a818-1509b4543d11" />

경량 프로세스는 다음과 같은 두 가지 한계를 지닌다.

- 커널 스레드를 기반으로 구현되기 때문에, 생성, 소멸, 동기화 등 다양한 스레드 연산이 시스템 호출로 이루어진다. (실행 비용이 높다)
- 경량 프로세스 하나가 커널 스레드 하나에 매핑되기 때문에 경량 프로세스는 일정량의 커널 자원을 소모한다.

#### 사용자 스레드 구현

사용자 스레드는 온전히 사용자 공간에서 구현되는 스레드 라이브러리를 가리킨다. <br.
따라서 운영 체제 커널은 사용자 스레드의 존재와 구현 방법을 알지 못한다. 사용자 스레드의 생성, 소멸, 동기화, 스케줄링은 모두 커널의 도움없이 온전히 사용자 공간에서 처리된다. <br>
제대로 구현하면 커널 모드로 전환할 필요가 전혀 없다. 매우 빠르고 저 렴하여 더 많은 스레드를 지원할 수 있다는 뜻이다.

#### 하이브리드 구현

커널 스레드와 사용자 스레드를 함께 이용하는 하이브리드 구현 방법도 있다. <br>
하이브리드 구현에서는 사용자 스레드와 경량 프로세스가 공존한다. <br>
사용자 스레드는 여전히 사용자 영역에 구현된다. 따라서 생성, 소멸, 스케줄링 비용이 저렴하고 감당할 수 있는 동시성 규모가 커진다. <br>
한편 운영 체제가 제공하는 경량 프로세스는 사용자 스레드와 커널 스레드 사이에서 가교 역할을 한다.

### 자바 스레드 스케줄링

**스레드 스케줄링이란 시스템이 프로세서 사용 권한을 스레드에 할당하는 일이다.** <br>
주요 스케줄링 방법으로는 협력적 스케줄링과 선점형 스케줄링이 있다.

**협력적 스케줄링** 시스템에서는 스레드 실행 시간을 스레드 스스로 제어한다. <br>
따라서 일을 마친 스레드는 다른 스레드로 전환되도록 시스템에 적극적으로 알려야 한다. <br>
협력적 모델의 가장 큰 이점은 구현하기 쉽고, 일반적으로 동기화 문제가 일어나지 않는다는 것이다. 스레드들은 다른 스레드로 전환하기 전에 자신이 완수해야 하는 일을 알고 있기 때문이다. <br>
단점으로는 스레드 실행 시간을 제어할 수 없다.

**선점형 스케줄링** 방식은 각 스레드의 실행 시간을 시스템이 할당한다. <br>
선점형 방식에서는 스레드 실행 시간을 시스템이 제어할 수 있어서 스레드 하나가 프로세스나 시스템 전체를 먹통으로 만드는 사태를 막을 수 있다. (자바가 이를 이용한다.) <br>
자바 스레드의 스케줄링은 시스템이 자동으로 수행하지만, 특정 스레드에 더 많거나 더 적은 실행 시간을 할당하도록 운영 체제에 **권고**할 수는 있다. <br>

### 상태 전이

자바 언어에서 스레드의 상태는 총 여섯 가지다. 어느 시점이든 스레드는 이 중 한 상태에 놓이며, 특정 메서드를 호출하여 다른 상태로 전이할 수 있다.

- 신규: 스레드 생성 후 아직 시작되기 전 상태를 말한다.
- 실행 중: 운영 체제 스레드의 상태 중에서 실행 중과 준비에 해당한다. 스레드가 실행 중이거나 운영 체제가 실행 시간을 할당하기를 기다리는 중이다.
- 무기한 대기:  프로세서 실행 시간이 할당되지 않았고, 다른 스레드가 명시적으로 깨워 주기를 기다리는 중이다.
- 시간 제한 대기: 프로세서 실행 시간이 할당되지 않았으나 (다른 스레드가 명시적으로 깨워 주기를 기다릴 필요 없이) 일정 시간이 지나면 시스템에 의해 자동으로 깨어난다.
- 블록: 스레드가 블록되었다. 일정 시간 동안 또는 다른 스레드가 깨워 주기를 기다리는 것이다.
- 종료: 스레드가 실행을 마쳤다.

<img width="579" alt="Image" src="https://github.com/user-attachments/assets/d5237199-c91f-4ff9-aebd-e26c384a2228" />

## 자바와 가상 스레드

자바는 다양한 운영 체제별 스레드 모델의 차이를 숨기는 통합된 스레드 인터페이스를 제공하는데, 이는 자바 탄생 초기에 여타 프로그래밍 언어에 비해 큰 장점으로 작용했다. <br>
그 덕분에 멀티스레딩을 깊이 공부하지 않은 개발자도 어지간한 동시성 프로그래밍을 무리없이 할 수 있다.

### 커널 스레드의 한계

자바 가상 머신들은 주로 1:1 커널 스레드 모델을 채택해 왔다. 자바 스레드가 운영 체제 스레드에 매핑되면서 자연스럽게 전환과 스케줄링 비용이 커지고 시스템 이 수용할 수 있는 스레드 수도 크게 제한된다. <br>
과거 모놀리식 애플리케이션에서는 요청 하나의 처리 시간이 상대적으로 길었기 때문에 스레드 전환 비용이 크게 부각되지 않았다. <br>
하지만 이제는 요청당 실행 시간이 매우 짧아지고 수가 많아진 것이다. 결국 사용자 스레드 전환 부하가 계산 자체의 부하에 근접해지면서 심각한 낭비를 초래하게 되었다.

### 코루틴의 귀환

커널 스레드의 스케줄링 비용은 주로 사용자 모드와 커널 모드 사이의 전환 비용 이며, 이 비용은 주로 인터럽트에 응답하고 실행 사이트의 데이터를 저장했다가 복원하는 비용이다. <br>

> 스레드 A -> 시스템 인터럽트 -> 스레드 B와 같은 스레드 전환 시나리오를 생각해보자. <br>
> 프로세서가 스레드 A의 프로그램 코드를 실행하려면 프로그램의 동작을 의미하는 코드와 함께 context data도 준비되어야 한다. <br>
> 따라서 인터럽트가 발생하여 스레드 A에서 B로 전환해야 한다면, 운영 체제는 먼저 A의 문맥 데이터를 적절히 보관한 다음, 레지스터와 메모리 페이징 등을 B가 이전에 일시 정지된 시점과 똑같게 복원해야 한다. <br>
> 문맥을 저장하고 복원하는 작업에는 필연적으로 다양한 레지스터와 캐시에 저장된 일련의 데이터를 이리저리 복사하는 일이 뒤따른다

### 가상 스레드: 자바의 해법

<img width="604" alt="Image" src="https://github.com/user-attachments/assets/855ff53a-c5e5-4a2d-8f73-958dab5a8633" />

**가상 스레드는 플랫폼 스레드와 N:1 관계다.** <br>
가상 스레드 하나가 블록되면 플랫폼 스레드는 연결된 다른 가상 스레드의 작업을 이어서 진행한다. <br>
이런 식으로 커널 스레드는 문맥 전환없이 쉬지 않고 애플리케이션 코드를 실행하는 것이다.









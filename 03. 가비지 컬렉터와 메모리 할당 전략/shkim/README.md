# 가비지 컬렉터와 메모리 할당 전략

가비지 컬렉션이 처리해야 하는 문제 세 가지

- 어떤 메모리를 회수해야 하나
- 언제 회수해야 하나
- 어떻게 회수해야 하나

자바 힙과 메서드 영역은 불확실한 게 아주 많다. 같은 인터페이스라 해도 구현한 클래스마다 요구하는 메모리 크기가 다를 수 있다. <br>
하나의 메서드에서도 어떤 조건 분기를 실행하느냐에 따라 메모리 요구량이 달라질 수 있다. 프로그램이 어떤 객체를 생성할지, 얼마나 많이 만들지는 오직 런타임에만 알 수 있는 것이다. <br>
그래서 이 메모리 영역들의 할당과 회수는 동적으로 이루어진다. 가비지 컬렉터는 이런 영역을 관리하는 데 집중한다.

## 대상이 죽었는가 ?

자바 세계 에서는 거의 모든 객체 인스턴스가 힙에 저장된다. <br>
가비지 컬렉터가 힙을 청소하려면 가장 먼저 어떤 객체가 살아 있고, 또 어떤 객체가 죽었는지 판단해야 한다

### 참조 카운팅 알고리즘

1. 객체를 가리키는 참조 카운터를 추가한다. 참조하는 곳이 하나 늘어날 때마다 카운터 값을 1씩 증가시킨다.
2. 참조하는 곳이 하나 사라질 때마다 카운터 값을 1씩 감소시킨다.
3. 카운터 값이 0이 된 객체는 더는 사용될 수 없다.

하지만 자바에서는, 적어도 자바 가상 머신에서는 참조 카운팅을 쓰지 않는다. <br>
이 간결한 알고리즘에도 고려해야 할 특이 상황이 적지 않고, 모든 상황에서 문제없이 동작하게 하려면 계산할 게 상당히 늘어나기 때문이다. <br>
**예를 들어 간단한 참조 카운팅만으로는 순환 참조 문제를 풀기 어렵다.**

### 도달 가능성 분석 알고리즘

자바, C# 등 오늘날의 주류 프로그래밍 언어들은 모두 객체 생사 판단에 도달 가능성 분석 알고리즘을 이용한다. <br>
이 알고리즘의 기본 아이디어는 GC 루트라고 하는 루트 객체들을 시작 노드 집합으로 쓰는 것이다. <br>
시작 노드들에서 출발하여 참조하는 다른 객체들로 탐색해 들어간다. <br>
그리고 어떤 객체와 GC 루트 사이를 이어 주는 참조 체인이 없다면, 즉 GC 루트로부터 도달 불가능한 객체는 더 이상 사용할 수 없는 게 확실해진다.

<img width="622" alt="스크린샷 2025-01-04 오후 3 47 32" src="https://github.com/user-attachments/assets/2fd88f18-6a2e-4665-b1c7-0739250a9e5d" />

자바에서 GC 루트로 이용할 수 있는 객체는 정해져 있다.

- 가상 머신 스택에서 참조하는 객체: 현재 실행중인 메서드에서 쓰는 매개 변수, 지역 변수, 임시 변수 등
- 메서드 영역에서 클래스가 정적 필드로 참조하는 객체: スト바 클래스의 참조 타입 정적 변수
- 메서드 영역에서 상수로 참조되는 객체: 문자열 테이블 안의 참조
- 네이티브 메서드 스택에서 JNI가 참조하는 객체
- 자바 가상 머신 내부에서 쓰이는 참조: 기본 데이터 타입에 해당하는 Class 객체 (NullPointerException, OutOfMemoryError 등)
- 동기화 락으로 잠겨있는 모든 객체
- 자바 가상 머신 내부 상황을 반영하는 JMXBean： JVMTI에 등록된 콜백, 로컬 코드 캐시 등

### 다시 참조 이야기로

JDK 1.2부터 참조 개념이 확장되어 참조를 네 가지로 구분하기 시작했다.

- 강한 참조: Object obj = new Object()처럼 프로그램 코드에서 참조를 할당하는 걸 말한다.강한 참조 관계가 남아 있는 객체는 가비 지 컬렉터가 절대 회수하지 않는다.
- 부드러운 참조: 유용하지만 필수는 아닌 객체를 표현한다. 부드러운 참조만 남은 객체라면 메모리 오버플로가 나기 직전에 두 번째 회수를 위한 회수 목록에 추가된다.
- 약한 참조: 부드러운 참조와 비슷하지만 연결 강도가 더 약하다. 약한 참조뿐인 객체는 다음번 가비지 컬렉션까지만 살아 있다. 가비지 컬렉터가 동작하기 시작하면 메모리가 넉넉하더라도 약하게 참조된 객체는 모두 회수된다.
- 유령 참조: 유령 참조는 객체 수명에 아무런 영향을 주지 않으며 , 유령 참조를 통해 객체 인스턴스를 가져오는 것마저 불가능하다. 유령 참조를 거는 유일한 목적은 대상 객체가 회수될 때 알림을 받기 위해서다. 


### 살았나 죽었나 ?

도달 가능성 분석 알고리즘이 '도달 불가능'으로 판단한 객체라고 해서 반드시 죽어야 하는 건 아니다. 아직 유예 단계가 남았다. <br>
확실한 사망 선고를 내리려면 두 번의 표시(marking) 과정을 거쳐야 한다.

도달 가능성 분석으로 GC 루트와 연결된 참조 체인을 찾지 못한 객체에는 첫 번째 표시가 이루어지며 이어서 필터링이 진행된다. <br>
필터링 조건은 **종료자(finalizer) 메서드를 실행해야 하는 객체인가** 이다. <br>
finalizer를 실행해야 하는 객체로 판명되면 F-Queue라는 대기열에 추가된다. 그러면 가상 머신이 나중에 우선순위가 낮은 종료자 스레드를 생성해 F-큐에 들어있는 객체들의 finalize() 메서드를 실행한다.


### 메서드 영역 회수하기

가비지 컬렉터가 메서드 영역을 반드시 청소해야 하는 건 아니다. 실제로도 메서드 영역 타입 언로딩을 구현하지 않거나 완벽하게 수행하지 않는 가상 머신도 있다. <br>
**메서드 영역 가비지 컬렉션은 대체로 '비용 효율'이 좋지 않기 때문이다.** <br>
일반적인 애플리케이션에서 자바 힙은, 그중에서도 특히 신세대는 가비지 컬렉션 한 번으로 메모리 공간의 70〜99%를 회수해 낸다. 반면 메서드 영역은 회수 조건이 까다로워서 효율이 훨씬 떨어진다. <br>

**메서드 영역의 가비지 컬렉션은 크게 두 가지를 회수한다. 더 이상 사용되지 않는 상수와 클래스다.** <br>
다 쓴 '상수'를 회수하는 방법도 자바 힙에서 객체를 회수하는 방법과 매우 비슷하다. <br>
문자열 "java"가 상수 풀에 들어있으나, 현재 시스템에서 값이 "java"인 문자열 객체는 하나도 없다고 해 보자. <br>
이 시점에 회수가 시작되면 가비지 컬렉터는 "java" 상수를 상수 풀에서 치워 버려야 한다고 판단할 것이다.

**다 쓴 상수인지 판단하는 일은 비교적 간단하지만, 더 이상 쓰이지 않는 클래스인지 판단하는 조건은 더 까다롭다. 다음 세 조건을 동시에 만족해야 한다.** <br>
자바 가상 머신은 세 조건에 부합하는 쓸모없는 클래스들을 회수하도록 허용한다. 그런데 '허용'한다고 했지, 반드시 회수한다고 하지는 않았다.

- 이 클래스의 인스턴스가 모두 회수되었다. 즉, 자바 힙에는 해당 클래스와 하위 클래스의 인스턴스가 하나도 존재하지 않는다.
- 이 클래스를 읽어 들인 클래스 로더가 회수되었다.
- 이 클래스에 해당하는 java.lang.Class 객체를 아무 곳에서도 참조하지 않고, 리플렉션 기능으로 이 클래스의 메서드를 이용하는 곳도 전혀 없다.


## 가비지 컬렉션 알고리즘

객체의 생사를 판별하는 방식을 기준으로 가비지 컬렉션 알고리즘을 '참조 카운팅 GC'와 '추적 GC'로 나눌 수 있다. <br>
이 둘을 '직접 가비지 컬렉션'과 '간접 가비지 컬렉션'이라 부르기도 한다.

### 세대 단위 컬렉션 이론

1. 약한 세대 가설: 대다수 객체는 일찍 죽는다.
2. 강한 세대 가설: 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.

자바 힙을 몇 개의 영역으로 나누고 객체들을 나이에 따라 각기 다른 영역에 할당하는 것이다. 여기서 나이란 가비지 컬렉션에서 살아남은 횟수를 말한다. <br>
영역 안의 객체 대부분이 곧바로 죽을 운명이라면, 그 객체들을 한데 몰아넣고 살아남는 소수의 객체를 유지하는 방법에 집중하는 편이 유리하다. <br>
한 번 살아남은 객체는 통계적으로 잘 죽지 않으니 다른 영역에 따로 모아 두고, 가상 머신이 그 영 역을 회수하는 빈도를 줄이는 것이다.

자바 힙을 여러 영역으로 나누면 가비지 컬렉터슨 한 번에 하나 또는 몇 개 영역만 선택해 회수할 수 있는데 이를 기준으로 **마이너 GC, 메이저 GC, 전체 GC**식으로 부르곤 한다. <br>
각 영역에 담긴 객체들의 생존 특성에 따라 **마크-스윕, 마크-카피, 마크-컴팩트**등의 가비지 컬렉션 알고리즘을 구분해 적용한다.

세대 단위 컬렉션 이론을 가상 머신에 적용한 설계자들은 자바 힙을 최소 두 개 영역으로 나눈다. 바로 신세대와 구세대다. <br>
**신세대에서는 가비지 컬렉션 때마다 다수의 객체가 죽고 살아남은 소수만 구세대로 승격된다.** <br>
**신세대에서만 가비지 컬렉션을 하고 싶더라도 신세대에 속하지만 구세대에서 참조 중인 객체도 충분히 있을 수 있다.** <br>
따라서 살아남을 객체를 찾으려면 도달 가능성을 분석할 때 고정 된 GC 루트들뿐 아니라 구세대 객체까지 모두 탐색해야 결과를 신뢰할 수 있다. <br>
이 문제를 풀려면 세대 단위 컬렉션 이론에 세 번째 경험 법칙을 추가해야 한다.

3. 세대 간 참조 가설: 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.

이 가설에 따르면 세대 간 참조의 수는 아주 적기 때문에 구세대 전체를 훑는 건 낭비다. <br>
또한 어떤 객체들이 존재하고 어떤 세대 간 참조가 있는지 일일이 기록하느라 공간을 낭비할 필요도 없다. <br>
그저 신세대에 기억 집합이라는 전역 데이터 구조를 하나 두면 된다. 이 구조를 통해 구세대를 작은 조각 몇 개로 나누고, 그중 어느 조각에 세대 간 참조가 있는지 기록해 관리하는 것이다.

### 마크-스윕 알고리즘

이 알고리즘은 작업을 표시와 쓸기라는 두 단계로 나눠 진행한다. <br>
먼저 회수할 객체들에 모두 표시한 다음, 표시된 객체들을 쓸어 담는 식이다. <br>
마크-스윕 알고리즘의 큰 단점은 두 가지다.

1. 실행 효율이 일정하지 않다. 객체가 많아질수록 표시하고 쓸어 담는 작업의 효율이 떨어지는 구조다.
2. 메모리 파편화가 심하다. 가비지 컬렉터가 쓸고 간 자리에는 불연속적인 메모리 파편이 만들어진다. 파편화가 너무 심하면 프로그램이 큰 객체를 만들려 할때 충분한 크기의 연속된 메모리를 찾기가 점점 어려워지고, 그 결과 또 다른 가비지 컬 렉 션을 유발한다.

### 마크-카피 알고리즘

이 알고리즘은 가용 메모리를 똑같은 크기의 두 블록으로 나눠 한 번에 한 블록만 사용한다. 한쪽 블록이 꽉 차면 살아남은 객체들만 다른 블록에 복사하고 기존 블록을 한 번에 청소한다. <br>
대다수 객체가 살아남는다면 메모리 복사에 상당한 시간을 허비하는 반면, 대다수가 회수된다면 생존한 소수의 객체만 복사하면 된다. 더욱이 복사 과정에서 객체들이 메모리의 한쪽 끝에서부터 차곡차곡 쌓이기 때문에 골치 아픈 메모리 파편화 문제로부터 해방된다. <br>
이 알고리즘의 단점은 가용 메모리를 절반으로 줄여 낭비가 심하다는 점이다. <br>
오늘날 상용 자바 가상 머신 대부분은 신세대에 이 알고리즘을 활용한다.

### 마크-컴팩트 알고리즘

표시 단계는 마크-스윕과 같다. 하지만 다음 컴팩트 단계에서 생존한 모든 객체를 메모리 영역의 한쪽 끝으로 모은 다음, 나머지 공간을 한꺼번에 비운다. <br>
마크-스윕과의 핵심적인 차이는 메모리 이동이 일어난다는 점이다. <br>
이런 식의 객체 이동은 사용자 애플리케이션을 모두 멈춘 상태에서 진행해야 하므로 아주 신중하게 고려해야 할 단점이다.

## 핫스팟 알고리즘 상세 구현

### 루트 노드 열거

**루트 노드 열거란 도달 가능성 분석 알고리즘에서 GC 루트 집합으로부터 참조 체인을 찾는 작업을 말한다.** <br>
GC 루트로 고정할 수 있는 노드는 주로 전역 참조(상수와 클래스 정적 속성 등)와 실행 콘텍스트(스택 프레임의 지역 변수 테이블 등)에 존재한다. <br>
**핫스팟은 OopMap이라는 데이터 구조를 이용해 사용자 스레드가 정지한 후 실행 콘텍스트와 전역 참조의 위치를 빠짐없이 확인할 필요가 없다.** <br>
클래스 로딩이 완료되면 객체에 포함된 각 데이터의 타입을 확인하고, JIT 컴파일 과정에서 스택의 어느 위치와 어느 레지스터의 데이터가 참조인지 기록한다. <br>
이런 식으로 컬렉터슨 메서드 영역과 다른 GC 루트들로부터 시작하여 추적해 보지 않고도 스캔 과정에서 이 정보를 직접 얻어 낸다.

### 안전 지점

핫스팟은 OopMap을 활용하여 GC 루트들을 빠르고 정확하게 열거할 수 있다. <br>
핫스팟은 모든 명령어 각각에 OopMap을 생성하지는 않는다. (참조 관계나 OopMap의 내용을 변경할 수 있는 명령어가 많고, 이런 명령어 모두에 OopMap을 만들어 넣으면 메모리를 더 많이 사용해야 한다) <br>
**그래서 핫스팟은 모든 명령어 각각에 OopMap을 생성하지는 않는다. 그 대신 안전지점이라는 특정한 위치에만 기록한다.** <br>
가비지 컬렉터슨 사용자 프로그램이 안전 지점에 도달할 때까지는 절대 멈춰 세우지 않는다.

### 안전 지역

**안전 지점을 사용하면 사용자 스레드를 멈춰 세운 후 가비지 컬렉션을 수행하는 문제가 완벽하게 해결되는 듯 보인다. 하지만 실상은 꼭 그렇지만은 않다.** <br>
안전 지점 메커니즘은 실행 중인 프로그램이 그리 길지 않은 시간에 안전 지점에 도달하여 가비지 컬렉션 프로세스가 제대로 임무를 다할 수 있게끔 보장한다. <br>
하지만 실행중이 아닌 프로그램이라면, 가상 머신의 인터럽트 요청에 응답할 수 없고, 따라서 안전 지점까지 수행한 후 인터럽트되어 스스로를 일시 정지시킬 수 없다.

**안전 지역은 일정 코드 영역에서는 참조 관계가 변하지 않음을 보장한다.** <br>
안전 지역 안이라면 어디서든 가비지 컬렉션을 시작해도 무방하다는 뜻이다.

### 기억 집합과 카드 테이블

가비지 컬렉터는 신세대에 기억 집합이라는 데이터 구조를 두어 객체들의 세대 간 참조 문제를 해결한다고 했다. <br>
그런데 세대 간 참조가 신세대와 구세대 사이로 국한되는 것은 아니다. GC를 지원하는 모든 가비지 컬렉터가 세대 간 참조 문제를 겪을 수 있다. <br>
기억 집합은 비회수 영역에서 회수 영역을 가리키는 포인터들을 기록하는 추상 데이터 구조다. <br>
가비지 컬렉션 시 컬렉터는 기억 집합을 이용해 특정 비회수 영역에서 회수 영역을 가리키는 포인터가 존재하는지만 확인하면 된다.

기억 집합은 사실 추상 데이터 구조다. 기억 집합의 동작 의도만 정의했을 뿐, 구체적인 구현 방법은 정의하지 않았다는 뜻이다. <br>
카드 테이블은 기록 정밀도와 힙 메모리의 매핑 관계 등을 정의하여 기억 집합을 구체적으로 구현한 방법 중 하나다. <br>
**카드 테이블과 기억 집합의 관계는 자바 언어에서 HashMap과 Map의 관계 정도로 이해하면 좋을 것이다.**

### 쓰기 장벽

기억 집합을 이용해 GC 루트의 스캔 범위를 줄이는 문제를 해결했다. <br>
하지만 카드 테이블 원소를 관리하는 문제, 예를 들어 언제 더럽혀지고 더럽히는 주체는 무엇인지 같은 문제가 남아 있다.

**카드 테이블의 원소가 언제 더럽혀지는지는 명확하다. 다른 세대의 객체가 현 블록 안의 객체를 참조하면 카드 테이블의 해당 원소가 더럽혀진다.** <br>
원칙적으로 더럽혀지는 시점은 참조 타입 필드에 값이 대입되는 순간이다. <br>
하지만 문제는 더럽혀졌다는 표시를 어떻게 하느냐, 즉 객체가 대입되는 순간 해당 카드 테이블을 어떻게 갱신하느냐다. <br>
**핫스팟 가상 머신은 쓰기 장벽 기술을 이용해 카드 테이블을 관리한다.** <br>
**쓰기 장벽은 가상 머신 수준에서 참조 타입 필드 대입 시 끼어드는 AOP에 비유할 수 있다.**

### 동시 접근 가능성 분석

현재 주류 프로그래밍 언어의 가비지 컬렉터들은 기본적으로 도달 가능성 분석 알고리즘을 써서 객체의 생사를 판단한다고 했다. <br>
**이론적으로 도달 가능성 분석 알고리즘은 일관성이 보장되는 스냅숏 상태에서 전체 과정을 진행해야 한다. 다시 말해 사용자 스레드는 분석 과정 내내 멈춰 있어야 한다.** <br>
참조 관계를 추적하는 가비지 컬렉션 알고리즘들에는 공통적으로 표시 단계가 등장한다. 표시 단계의 일시 정지 시간이 힙 크기에 비례해 증가한다면 거의 모든 가비지 컬렉터에 악영향을 준다는 뜻이다. <br>
**이 단계의 일시 정지 시간을 줄일 수 있다면 거의 모든 컬렉터에 득이 된다.**

> 흰색: 가비지 컬렉터가 방문한 적 없는 객체 <br>
> 검은색: 가비지 컬렉터가 방문한 적 있으며, 이 객체를 가리키는 모든 참조를 스캔했다. 검은 객체는 스캔되었고 확실히 생존함을 뜻한다. <br>
> 회색: 가비지 컬렉터가 방문한 적 있으나 이 객체를 가리키는 참조 중 스캔을 완료하지 않은 참조가 존재한다.

접근 가능성 분석의 스캔 과정은 마치 회색 물결이 일렁이며 하얀 객체 그래프를 검은색으로 칠해 가는 모습과 비슷하다. <br>
그동안 사용자 스레드들은 멈춘 채로 컬렉터의 GC 스레드만 실행된다면 아무 문제가 없다. 하지만 사용자 스레드와 컬렉터가 동시에 실행된다면 어떨까?

- 죽은 객체를 살았다고 잘못 표시할 수 있다.
- 살아 있는 객체를 죽었다고 표시할 수 있다.

<img width="659" alt="스크린샷 2025-01-04 오후 5 20 53" src="https://github.com/user-attachments/assets/27029b76-5a26-43fa-ac62-10f56af1e54c" />

**동시 스캔 도중 객체 사라짐 문제를 해결하려면 두 조건 중 하나만 깨뜨리면 된다. 바로 증분 업데이트와 시작 단계 스냅숏이다.** <br>
**증분 업데이트**는 검은색 객체에 흰색 객체로의 참조가 추가되면 새로 추가된 참조를 따로 기록해 둔다. 그리고 동시 스캔이 끝난 후 기록해 둔 검은색 객체들을 루트로 하여 다시 스캔한다. <br>
**시작 단계 스냅숏**은 회색 객체가 흰색 객체로의 참조 관계를 끊으려 하면 그 사실을 기록한다. 동시 스캔이 끝난 후 기록해둔 회색 객체들을 루트로 하여 다시 스캔한다.

## 클래식 가비지 컬렉터

**컬렉션 알고리즘이 방법론이라면 가비지 컬렉터슨 실무자다.**

<img width="586" alt="스크린샷 2025-01-04 오후 5 23 50" src="https://github.com/user-attachments/assets/21a38c2d-3920-42e1-9948-bbb0124ebc48" />

### 시리얼 컬렉터

**가장 기초적이고 오래된 컬렉터로, 이 컬렉터는 단일 스레드로 동작한다.** <br>
가비지 컬렉션이 시작되면 회수가 완료될 때까지 다른 모든 작업 스레드가 멈춰있어야 한다.

### 파뉴 컬렉터

**파뉴 컬렉터는 여러 스레드를 활용하여 시리얼 컬렉터를 병렬화한 버전이다.** <br>
여러 스레드를 사용한 병 렬 회수 외에 파뉴 컬렉터가 시리얼 컬렉터보다 나아진 점은 딱히 없다.

### 패러렐 스캐빈지 컬렉터

마크-카피 알고리즘에 기초하며 여러 스레드를 이용해 병렬로 회수하는 등, 많은 면에서 파뉴 컬렉터와 닮았다. <br>
**PS 컬렉터의 특징은 다른 컬렉터들과는 다른 데 집중한다.** <br>
PS 컬렉터는 처리량을 제어하는게 목표다. 

<img width="546" alt="스크린샷 2025-01-04 오후 5 27 47" src="https://github.com/user-attachments/assets/456e1fcc-3de1-4649-9f47-6d5a110df3eb" />

### 시리얼 올드 컬렉터

시리얼 올드 컬렉터슨 시리얼 컬렉터의 구세대용 버전이다. 마찬가지로 단일 스레드 컬렉터이며 마크-컴팩트 알고리즘을 쓴다. <br>
이 컬 렉터도 주로 클라이 언트용 핫스팟 가상 머신에서 사용한다.

### 패러렐 올드 컬렉터

패러렐 올드 컬렉터슨 PS 컬렉터의 구세대용 버전이다. 멀티스레드를 이용한 병렬 회수를 지원하며 마크-컴팩트 알고리즘을 기초로 구현되었다. <br>
패러렐 올드 컬렉터의 등장으로 처리량을 중시하는 PS 컬렉터는 마침내 딱 맞는 파트너를 찾게 되었다. 처리량이 중요하거나 프로세서 자원이 부족한 상황이라면 PS와 패러렐 올드 조합을 고려해 보자.

### CMS 컬렉터

CMS 컬렉터슨 표시와 쓸기 단계 모두를 사용자 스레드와 동시에 수행한다. <br>
CMS 컬렉터의 목적은 가비지 컬렉션에 따른 일시 정지 시간을 최소로 줄이는 것이다. <br>
마크-스윕 알고리즘을 기초로 구현되었고, 전체 과정은 다음 네 단계이다.

1. 최초 표시
2. 동시 표시
3. 재표시
4. 동시 쓸기

**최초 표시와 재표시 단계는 여전히 스톱 더 월드 방식이다.** <br>
최초 표시 단계에서는 GC 루트와 직접 연결된 객체들만 표시하기 때문에 아주 빠르게 끝난다. <br>
동시 표시 단계에서는 GC 루트와 직접 연결된 객체들로부터 시작해 객체 그래프 전체를 탐색한다. 시간이 오래 걸리지만 사용자 스레드를 멈추지는 않는다. <br>
재표시 단계에서는 동시 표시 도중 사용자 스레드가 참조 관계를 변경한 객체들을 바로잡는다. <br>
동시 쓸기 단계에서는 앞의 세 가지 표시 단계에서 죽었다고 판단한 객체들을 쓸어 담는다.

### G1 컬렉터 (가비지 우선 컬렉터)

**G1은 부분 회수라는 컬렉터 설계 아이디어와 리전을 회수 단위로 하는 메모리 레이아웃 분야를 개척했다.** <br>
G1 은 주로 서버용 애플리케이션에 집중한 컬렉터다. 핫스팟 개발 팀은 G1 이 장기적으로는 CMS를 대체하리라 기대했고 결국 목표를 이뤘다.

CMS의 대체제이자 후계자를 목표로, G1 의 설계자들은 정지 시간 예측 모델을 만들고자 했다. <br>
이는 목표 시간을 M밀리초로 설정하면 가비지 컬렉터가 쓰는 시간이 M밀리초가 넘지 않도록 통제하는 것이다. <br>
**G1 은 힙 메모리의 어느 곳이든 회수 대상에 포함할 수 있다. 어느 세대 에 속하느냐가 아니라 '어느 영역에 쓰레기가 가장 많으냐'와 '회수했을 때 이득이 어디가 가장 크냐'가 회수 영역을 고르는 기준이 된 것이다.** <br>
**G1 이 개척한 영역 기반 힙 메모리 레이아웃이 정지 시간 예측 모델이라는 목표를 이루는 열쇠다.** <br>
G1은 크기와 수가 고정된 세대 단위 영역 구분에서 벗어나, 연속된 자바 힙을 동일 크기의 여러 독립 리전으로 나눈다. <br>
각 리전은 필요에 따라 신세대의 에덴이나 생존자 공간이 될 수도, 구세대용 공간으로 쓰일 수도 있다. <br>
G1 은 리전 각각에 역할별 전략을 구분하여 적용할 수 있어서 회수 효율을 극대화한다.

**한편 큰 객체를 저장하기 위해 거대 리전이라는 특별한 유형도 활용한다.** <br>
G1 은 리전 용량의 절반보다 큰 객체를 큰 객체로 취급한다.

<img width="744" alt="스크린샷 2025-01-04 오후 5 38 18" src="https://github.com/user-attachments/assets/bd986e2d-0dcf-403f-aacb-b89225799943" />

> G1 에서 정지 시간 예측 모델이 가능한 이유는 리전을 최소 회수 단위로 사용하기 때문이다. <br>
> 즉, 매번 적절한 수의 리전을 계획적으로 회수하는 식으로 자바 힙 전체를 회수해야 하는 상황을 피할 수 있다.


G1 은 각 리전의 쓰레기 누적값을 추적한다. 여기서 값이란 가비지 컬렉션으로 회수할 수 있는 공간의 크기와 회수에 드는 시간의 경험값이다. <br>
그리고 우선순위 목록을 관리하며 사용자가 설정한 일시 정지 시간이 허용하는 한도내에서 회수 효과가 가장 큰 리전부터 회수하는 것이다. <br>
메모리 공간을 리전 단위로 분할해 우선순위대로 회수함으로써 제한된 시간 내에 가장 효율적으로 회수할 수 있는 것이다. <br>
사용자 스레드가 실행되는 동안 수행하는 작업（기억 집합을 관리하기 위해 쓰기 장벽을 사용하는 동작 등）을 제외한다면 G1 의 동작은 대략 다음 네 단계로 나뉜다.

1. 최초 표시: GC 루트가 직 접 참조하는 객 체들을 표시하고 TAMS 포인터의 값을 수정한다. 즉, 시작 단계 스냅숏을 생성한다.
2. 동시 표시: GC 루트로부터 시작하여 객체들의 도달 가능성을 분석하고, 전체 힙의 객체 그래프를 재귀적으로 스캔하며 회수할 객체를 찾는다. 
3. 재표시: 시작 단계 스냅숏 이후 변경된 소수의 객체만 처리하면 되므로 매우 빠르게 끝난다.
4. 복사 및 청소: 통계 데이터를 기초로 리전들을 회수 가치와 비용에 따라 줄 세운 다음, 목표한 일시 정지 시간에 부합하도록 회수 계획을 세운다.

**G1 컬렉터는 동시 표시 단계를 제외하고는 사용자 스레드를 멈춰야 한다.** <br>
G1의 공식 목표는 지연 시간을 제어하는 동시에 처리량을 최대한 높이는 것이다.

## 저지연 가비지 컬렉터

<img width="299" alt="Image" src="https://github.com/user-attachments/assets/7d7b773a-5806-4384-a2fc-3d8dfeaa83de" />

가비지 컬렉터를 측정하는 가장 중요한 지표는 세 가지다. 처리량, 지연 시간, 메모리 사용량이다. <br>
세 지표 중 지연 시간의 중요성이 점점 커지고 있다. 하드웨어가 발전하면서 컬렉터가 메모리를 살짝 더 사용하는 건 큰 문제가 되지 않는 추세다. <br>
또한 하드웨어 성능은 소프트웨어 시스템의 처 리량에 직결된다. 사양 좋은 하드웨어를 쓰면 컬렉터가 애플리케이션 동작에 미치는 영향이 그만큼 줄어든다. 달리 말해 처리량이 늘어난다.

하지만 지연 시간은 다르다. 메모리를 늘리면 지연 시간에는 악영향을 준다. <br>
힙 메모리 1TB를 청소하려면 1GB를 청소할 때보다 오래 걸리는 게 당연하다. <br>
이러한 이유들을 곱씹어 보면 가비지 컬렉터에서 가장 중요한 성능 지표가 왜 지연 시간이 되었는지 쉽게 이해될 것이다.

<img width="582" alt="Image" src="https://github.com/user-attachments/assets/d58abe22-22b4-4a80-ad10-d967de43811e" />

### 셰년도어

오라클은 JDK 12 시절에 셰넌도어 지원을 거부하는 입장을 밝힌 바 있으며 JDK 21까지도 여전히 지원 목록에서 빠져 있고 앞으로도 지원할 의사는 없어 보인다. <br>
셰넌도어는 오라클 JDK에는 없고 다른 회사（레드햇, 아마존 등）의 OpenJDK에만 존재하는 컬렉터다. <br>
셰넌도어 프로젝트의 목표는 힙 크기와 상관없이 가비지 컬렉션으로 인한 일시 정지를 10밀리초 이내로 묶어 두는 것이다. <br>
목표를 이루기 위해 셰넌도어는 표시 단계는 물론 객체 회수 후 마무리 작업까지 사용자 스레드와 동시에 수행해야 했다.

그렇다면 셰넌도어는 어떤 면에서 G1 보다 나아졌을까? <br>
셰넌도어 역시 힙을 리전들로 쪼개 처리하며, 큰 객체 전용의 거대 리전을 지원하고, 기본적으로 회수 가치가 큰 리전을 먼저 회수한다. <br>
하지만 최소 세 가지 면에서 확실히 다르다.

- 동시 모으기 지원
- JDK 21 까지의 셰넌도어는 세대 단위 컬렉션을 사용하지 않는다.
- 메모리와 컴퓨팅 자원을 많이 사용하는 기억 집합 대신 연결 행렬로 리전간 참조 관계를 기록한다.

<img width="476" alt="Image" src="https://github.com/user-attachments/assets/c5f8a1fc-84e7-43ea-a568-a83f857417f9" />

> **동작 방식** <br>
> 1. 최초 표시: 가장 먼저 GC 루트에서 직접 참조하는 객체들에 표시한다. 이 단계는 여전히 스톱 더 월드다.
> 2. 동시 표시: 객체 그래프를 타고 힙을 탐색하며 도달 가능한 모든 객체를 표시한다. 이 단계는 사용자 스레드와 동시에 수행된다.
> 3. 최종 표시: 보류 중인 모든 표시를 완료하고 GC 루트 집합을 다시 스캔한다. 또한 회수 가치가 가장 큰 리전들을 추려 회수 집합을 생성한다. 짧지만 일시 정지된다.
> 4. 동시 청소: 살아 있는 객체가 하나도 없는 리전들을 청소한다.
> 5. 동시 이주: 동시 이주는 셰넌도어를 핫스팟의 다른 컬렉터들과 구분해 주는 핵심적인 차이다. 이 단계에서는 회수 집합 안에 살아 있는 객체들을 다른 빈 리전으로 복사한다. <br>
> 사용자 스레드와 동시에 수행하기 위해, 셰넌도어는 읽기 장벽과 포워딩 포인터를 이용한다
> 6. 최초 참조 갱신: 동시 이주 단계에서 객체를 복사한 다음, 힙에서 옛 객체를 가리키는 모든 참조를 복사 후의 새로운 주소로 수정해야 한다. 사용자 스레드를 일시 정지시키지만 아주 금방 끝난다.
> 7. 동시 참조 갱신: 참조 갱신을 실제로 시작하며 사용スト 스레드와 동시에 수행한다. 객체 그래프를 탐색할 필요 없이, 물리 메모리 주소의 순서대로 참조 타입을 선형 검색하여 이전 값을 새로운 값으로 수정한다.
> 8. 최종 참조 갱신: 힙의 참조를 다 갱신했다면 GC 루트 집합의 참조도 갱신해야 한다. 이 단계가 셰넌도어의 마지막 일시 정지 단계다.
> 9. 동시 청소: 이주와 참조 갱신이 끝나면 회수 집합의 모든 리전에는 살아 있는 객체가 더 이상 남지 않게 된다. 그래서 동시 청소를 다시 수행하여 새로운 객체를 할당할 공간을 확보한다.


#### 동시 이주의 핵심, 포워딩 포인터

원래의 객체 레이아웃 구조 상단에 참조 필드를 하나 추가한다. <br>
동시 이주가 아닌 경우에는 참조 필드가 객체 자신을 가리킨다. <br>
포워딩 포인터가 가져다주는 이점은 포인터 하나의 값만 수정하면 끝이라는 것이다. <br>
옛 객체의 포워딩 포인터가 새로운 객체를 가리키도록 수정하기만 하면 된다.

<img width="285" alt="Image" src="https://github.com/user-attachments/assets/739b2d30-72ea-4f0f-b718-3c9c7627bb8d" />

여기서 주의할 점이 있다. <br>
브룩스가 설계한 포워딩 포인터 방식은 필연적으로 스레드들의 경쟁에 직면한다.

1. GC 스레드가 객체의 복사본을 만든다.
2. 사용자 스레드가 객체의 필드를 덮어쓴다.
3. GC 스레드가 옛 객체의 포워딩 포인터 값을 복사본의 주소로 수정한다.

2번 작업 이 아무런 보호 장치 없이 1번과 3번 사이 에 수행 된다면 사용자 스레드는 옛 객체를 변경하게 될 것이다. <br>
따라서 포워딩 포인터에 접근하는 동작을 동기화해야 한다. <br>
즉, GC 스레드와 사용자 스레드 중 하나만 포워 딩 포인터 에 접근할 수 있고, 다른 스레드는 순서를 기다려야 한다. <br>
셰년도어 컬렉터는 CAS 기법을 써서 동시 이주 중에도 객체 접근 시 문제가 없도록 했다.

포워딩 포인터와 관련하여 또 다른 주의 사항으로 '실행 빈도'가 있다. <br>
객체로의 접근에 속하는 동작을 모두 보호하려면 셰넌도어는 이 작업 모두에 읽기 장벽과 쓰기 장벽을 동시에 설정해야 한다. <br>
특히 읽기 장벽은 쓰기 장벽보다 비용이 크다. 일반적으로 코드에서 객체를 읽는 경우가 쓰는 경우보다 훨씬 많기 때문에 자연스럽게 쓰기 장벽보다 읽기 장벽을 거치는 횟수가 훨씬 많다. <br>
그래서 읽기 장벽에서 처 리하는 코드는 무거운 일을 하지 않도록 더욱 신경 써야 한다.

#### 계속되는 개선

- 로드 참조 장벽 도입
  - JDK 13에서 로드 참조 장벽을 이용해 셰넌도어의 메모리 장벽 모델을 개선했다. 로드 참조 장벽이란 객체 참조 타입의 데이터를 읽거나 쓸 때만 끼어드는 메모리 장벽 모델이다. <br>
    다시 말해 원시 데이터 타입처럼 참조가 아닌 필드를 읽거나 쓸 때는 간섭하지 않는다. 그 덕분에 원시 타입 데이터 관련 작업, 객체 비교, 객체 락 등의 시나리오에서는 <br>
    메모리 장벽을 설정하지 않아도 되어 오버헤드를 상당히 줄여 준다.
- 포워딩 포인터를 객체 헤더에 통합
  - JDK 13에서는 포워딩 포인터를 객체 헤더에 통합하는 작업도 함께 이루어졌다. <br>
    객체 헤더는 마크 워드, 클래스 워드, 배열 길이로 구성된다. 이 중 마크 워드의 마지막 2비트를 락 플래그라고 하며, 이 값에 따라 나머지 비트들의 의미가 달라진다. <br>
    그런데 락 플래그가 0b11일 때는 용도가 정의되어 있지 않다는 점에서 착안하여 마크 워드를 포워딩 포인터로 활용하는 방법을 찾게 되었다.

<img width="559" alt="Image" src="https://github.com/user-attachments/assets/34c60ddf-dd82-431e-83e8-86bc5d5115ef" />

포워딩 포인터 때문에 셰넌도어는 다른 가비지 컬렉터를 쓸 때보다 메모리를 5-10% 정도 더 소비하고 있었다. <br>
이 외에 포워딩 포인터 통합은 다음과 같은 이점을 제공했다.

- 같은 공간에 더 많은 객체를 담을 수 있어서 가비지 컬렉션 수행 횟수가 줄어든다.
- CPU 캐시에 더 많은 객체를 담을 수 있어서 캐시 적중률이 높아진다.
- 다른 가비지 컬렉터들과 객체 할당 코드를 공유할 수 있어서 구현 로직이 단순해진다.

- 스택 워터마크를 활용한 스레드 스택 동시 처리
  - JDK 17에 반영된 개선이다. <br>
    가비지 컬렉션이 시작되면 모든 스레드의 스택을 스캔하여 참조들을 표시 큐에 담는다. <br>
    이 과정에서 사용자 스레드들이 스택을 계속 변경하지 못하도록 스레드들을 안전 지점에 멈춰 세운 후 진행한다. <br>
    작업을 다 마치면 사용자 스레드들을 깨운 다음, 큐 안의 참조들로부터 도달 가능한 객체를 찾는다. <br>
    도달 가능한 객체들을 빈 리전으로 이주시킬 때는 스레드 스택 안의 참조들이 새로운 리전으로 옮겨진 객체를 가리키게 갱신해야 한다. 이 작업 역시 일시 정지가 필요하다. <br>
    **스레드 스택 중 변화가 생기는 부분은 최상위 스택 프레임뿐이다.** 이 사실은 곧 나머지 스택 프레임들은 사용자 스레드가 실행되는 중에도 GC 스레드가 마음 놓고 스캔할 수 있다는 뜻이다. <br>
    이 조율을 위해 셰넌도어는 스택 워터마크를 도입했다. <br>
    최초 표시 때는 모든 스레드의 최상위 프레임에 스택 워터마크를 설정한다. 사용자 스레드가 최상위 프레임을 스캔하고 워터마크를 한 칸 낮춘다. 동시에 GC 스레드는 스택을 밑에서부터 워터마크까지 스캔한다. <br>
    그리고 사용자 스레드는 최상위 스택 프레임을 파괴할 때마다 다음 과정을 거친다. <br>
  1. 워터마크를 한 칸 낮춘다.
  2. GC 스레드가 워터마크 위로는 스캔하지 못하게 막는다.
  3. 1의 결과로 워터마크 위로 떠오른 스택 프레임을 스캔한다.

<img width="670" alt="Image" src="https://github.com/user-attachments/assets/48284037-5b31-4e40-9f34-c1142690e9ac" />

### ZGC

ZGC는 오라클이 개발한 저지연 가비지 컬렉터다. <br>
ZGC와 셰넌도어의 목표는 아주 흡사하다. 둘 다 처리량에 미치는 영향을 최소로 억제하면서 힙 크기에 상관없이 가비지 컬렉션으로 인한 일시 정지 시간을 10밀리초 안쪽으로 줄이고자 했다. <br>
ZGC의 주요 특성은 다음과 같다.

> GC는 세대 구분 없이 리전 기반 메모리 레이아웃을 사용한다. 낮은 지연 시간을 <br>
> 최우선 목표로 하며, 동시 마크-컴팩트 알고리즘을 구현하기 위해 읽기 장벽, 컬러 <br>
> 포인터 , 메모리 다중 매핑 기술을 이용하는 가비지 컬렉터다

#### 리전 기반 메모리 레이아웃

ZGC의 리전은 동적으로 생성/파괴된다. 그뿐 아니라 크기도 동적으로 달라진다.

- 소리전: 2MB로 고정 되며 256KB 미만의 작은 객체를 담는다.
- 중리전: 32MB로 고정 되며 256KB 이상 4MB 미만 객체를 담는다.
- 대리전: 크기가 동적으로 변할 수 있다. 단, 2MB의 배수여야 한다. 최소 크기는 4MB다. ZGC는 대리전은 재할당하지 않는데, 큰 객체를 복사하는 비용이 매우 크기 때문이다

#### 병렬 모으기와 컬러 포인터

ZGC도 마찬가지로 읽기 장벽을 이용하지만 완전히 다르게, 셰넌도어보다 더 복잡하고 정교한 방식으로 사용한다. <br>
이동한 객체와 관련해 필요한 정보를 객체와 관련 없는 포인터나 장소로부터 얻을 수 있을까? <br>
참조 관계를 추적하여 객체의 생사를 판단하는 컬렉션 알고리즘의 표시 단계에서는 포인터만 처리하면 됐다. 즉, 포인터가 참조하는 객체까지 처리할 필요는 없었다. <br>
**ZGC의 컬러 포인터는 객체를 가리키는 포인터에 직접 표시한다.** <br>
따라서 이때 도달 가능성 분석은 객체 그래프를 순회하며 객체에 표시하는 일이 아니라, 참조 그래프를 순회하며 참조에 표시한다라고 이야기해야 더 적절하다.

- 한 리전 안의 생존 객체들이 이동하면 그 즉시 해당 리전을 재활용할 수 있다. <br>
  전체 힙에서 해당 리전으로의 참조들을 전부 수정할 때까지 기다릴 필요가 없다는 뜻이다.
- 가비지 컬렉션 과정에서 메모리 장벽의 수를 크게 줄일 수 있다. <br>
  메모리 장벽, 특히 쓰기 장벽을 설정하는 이유는 주로 객체 참조를 변경하기 위해서다. 이 정보를 포인터 자체에 둔다면 확실히 일부 기록 작업이 필요 없어진다. <br>
  실제로도 ZGC는 지금까지 쓰기 장벽을 전혀 사용하지 않고 오직 읽기 장벽만 사용한다.
- 컬러 포인터를 객체 표시 및 재배치와 관련해 더 많은 정보를 담을 수 있는 확장 가능한 저장 구조로 쓸 수 있다. <br>
  다시 말해 미래에 또 다른 성능 향상을 이끌어 낼 잠재력이 있다.

#### ZGC의 동작 방식

ZGC의 동작은 크게 네 단계로 나뉜다. <br>
네 단계 모두 사용자 스레드와 동시에 실행되지만, 사이사이에 사용자 스레드를 일시 정지시키는 작은 단계가 끼어 있다.

<img width="635" alt="Image" src="https://github.com/user-attachments/assets/0931163d-84b5-465d-a1b3-250a97a06921" />

1. 동시 표시: G1 과 셰넌도어처럼 동시 표시는 객체 그래프를 탐색하며 도달 가능성을 분석하는 단계다. <br>
   짧은 일시 정지가 발생하며, 이 일시 정지 동안 수행하는 일의 목표도 비슷하다. G1 이나 셰넌도어와 다른 점은, ZGC의 표시는 객체가 아니라 포인터에서 이루어진다는 것이다.
2. 동시 재배치 준비: 청소해야 할 리전들을 선정하여 재배치 집합을 만든다. <br>
   G1 과 달리 ZGC는 가비지 컬렉션 때마다 모든 리전을 스캔한다. G1 이 기억 집합을 관리하는 비용 대신 스캔을 광범위하게 하는 비용을 선택한 것이다. <br>
   그래서 ZGC의 재배치 집합에서는 리전 안의 생존 객체들을 다른 리전으로 복사한 후 리전 자체를 회수할지 여부만 결정한다.
3. 동시 재배치: 이 단계에서 재배치 집합 안의 생존 객체들을 새로운 리전으로 복사한다. <br>
   또한 재배치 집합에 속한 각 리전의 포워드 테이블에 옛 객체와 새 객체의 이주 관계를 기록한다. <br>
   사용자 스레드가 재배치 집합에 포함된 객체에 동시에 접근하려 들면 미리 설정해둔 메모리 장벽이 끼어들어, 즉시 해당 리전의 포워드 테이블에 기록된 정보를 보고 새로운 객체로 포워드시킨다. <br>
   그와 동시에 해당 참조의 값도 새로운 객체를 직접 가리키도록 갱신한다. ZGC에서는 이 동작을 포인터의 자가 치유라고 한다. <br>
   자가 치유의 장점은 옛 객체에 처음 접근할 때만 포워드가 일어난다는 것이다.
4. 동시 재매핑: 재매핑이란 힙 전체에서 재배치 집합에 있는 옛 객체들을 향하는 참조 전부를 갱신하는 작업이다. <br>
   
#### 세대 구분 ZGC

세대 구분 ZGC는 ZGC를 확장하여 신세대와 구세대를 구분하도록 했다. <br>
세대를 구분해서 얻는 가장 큰 이점은 물론 수명이 짧은 젊은 객체들을 더 자주 회수한다는 것이다. <br>
그 외에도 수많은 기법이 더 적용되어 세대 구분 ZGC를 더욱 뛰어난 가비지 컬렉터로 만들었다. 자원 사용량도 더 적기 때문에 일부 시나리오에서는 처리량도 눈에 띄게 증가했다.

- 다중 매핑 메모리 제거
  - 다중 매핑은 같은 힙 메모리를 세 개의 독립된 가상 주소로 매핑한다. 그래서 유닉스의 ps 같은 도구로 메모리 사용량을 확인하면 실제보다 3배가량 높게 측정된다. <br>
    한편 세대 구분 ZGC는 읽기 장벽과 쓰기 장벽의 코드를 명확히 구분한다. 그 덕분에 사용자 관점에서 메모리 사용량을 더 정확히 측정할 수 있다. <br>
    컬러 포인터 에서 다중 매핑 관련 메타데이터 비트들이 제거되니, 확보된 비트를 다른 용도로 활용할 수 있다.
- 다양한 장벽 최적화
  - 쓰기 장벽이 도입되고 읽기 장벽의 역할도 바뀌면서 , 더 많은 가비지 컬렉터 코드가 컴파일된 애플리케이션 코드에 섞여 실행되게 되었다. <br>
    기억 집합 장벽, 시작 단계 스냅숏 표시 장벽, 쓰기 장벽 버퍼, 장벽 패치 등 수많은 기법을 고안해 적용했다.
- 이중 버퍼를 이용한 기억 집합 관리
  - ZGC는 비트맵을 이용해서 객체 필드의 위치를 정확하게 기록한다. 비트맵의 비트 하나가 객체 필드 주소 하나를 표현한다. <br>
    그리고 구세대 리전 각각이 한 쌍의 기억 집합 비트맵을 가지고 있다. 비트맵 하나는 애플리케이션 스레드들의 쓰기 장벽에서 수정하게 되며, 그 읽기 전용 복사본인 다른 비트맵은 GC 스레드가 참고한다. <br>
    그리고 마이너 GC가 시작될 때마다 두 비트맵을 원자적으로 교환한다. 이로써 애플리케이션 스레드와 GC 스레드는 서로 신경 쓰지 않고 일을 진행할 수 있다.
- 밀집도 기반 리전 처리
  - 세대 구분 ZGC는 어느 리전부터 회수해야 할지 정하기 위해 신세대 리전들의 밀집도를 분석한다. <br>
    회수 대상으로 선정되지 않은 리전들은 그대로 나이를 먹어서 생존자 리전이 되거나, 나이를 더 먹으면 구세대 리전으로 승격된다. <br>
    생존자 리전들은 다음번 신세대 GC 때는 밀집도가 더 높아질 테니 회수 대상이 될 가능성이 커진다.
- 거대 객체 처리
  - 세대 구분 ZGC에서는 거대한 객체도 신세대에 바로 할당한다. 하지만 살아남은 거대한 객체를 구세대로 재배치하는 비용은 걱정할 필요가 없다. <br>
    객체 재배치 없이 리전을 노화시킬 수 있기 때문이다. 신세대에 할당된 거대 객체가 곧바로 죽는다면 신세대 GC 때 빠르게 회수하여 많은 양의 메모리를 확보할 수 있다. 반대로 오래 살아남는다면 해당 리전 자체가 그대로 구세대로 승격될 것이다.















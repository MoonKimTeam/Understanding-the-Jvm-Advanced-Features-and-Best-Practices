# 클래스 파일 구조

## 플랫폼 독립을 향한 초석

언어 독립성을 보장하는 핵심은 가상 머신과 바이트코드 저장 형식이다. <br>
자바 가상 머신은 자바를 포함하여 어떤 프로그래밍 언어에도 종속되지 않는다. <br>
**클래스 파일**이라는 특정한 바이너리 파일 형식에만 의존할 뿐이다.

<img width="723" alt="Image" src="https://github.com/user-attachments/assets/6038d2bb-ef19-48f3-b608-95878cacb10d" />

## 클래스 파일의 구조

자바 가상 머신 명세에 따르면 클래스 파일에 데이터를 저장하는 데는 C 언어의 구조체와 비슷한 의사 구조를 이용한다. <br>
이 의사 구조에는 부호 없는 숫자와, 테이블이라는 두 가지 데이터 타입만 존재한다.

- 부호 없는 숫자: 기본 데이터 타입을 표현한다. u1, u2, u4, u8은 각각 1바이트, 2바이트, 4바이트, 8바이트를 뜻한다. 숫자, 인덱스 참조, 수량 값을 기술하거나 UTF-8로 인코딩된 문자열 값을 구성할 수 있다.
- 테이블: 여러 개의 부호 없는 숫자나 또 다른 테이블로 구성된 복합 데이터 타입을 표현한다. 테이블은 계층적으로 구성된 복합 구조의 데이터를 설명하는 데 사용된다. 클래스 파일 전체는 본질적으로 테 이블이며 구조는 다음과 같다.

```
ClassFile {
    u4          magic;
    u2          minor_version;
    u2          major_version;
    u2          constant_pool_count;
    cp_info     constant_pool[constant_pool_count-1];
    ...
```

### 매직 넘버와 클래스 파일의 버전

모든 클래스 파일의 처음 4바이트는 매직 넘버로 시작한다. <br>
매직 넘버는 가상 머신이 허용하는 클래스 파일인지 여부를 빠르게 확인하는 용도로만 쓰인다. <br>
클래스 파일뿐 아니라 다양한 파일 형식에서 파일 타입 식별용으로 매직 넘버를 즐겨 쓴다. (GIF, JPEG같은 이미지 파일도 파일 헤더에 매직 넘버가 등장한다.) <br>

매직 넘버 다음의 4바이트는 클래스 파일의 버전 번호다. <br>
5~6번쨰 바이트는 마이너 버전을, 7~8번쨰 바이트는 메이저 버전을 뜻한다. <br>
자바 버전 번호는 45번부터 시작한다. JDK 1.1 이후 주요 JDK 릴리스의 메이저 버전은 1씩 증가하며, 상위 버전 JDK는 하위 버전을 인식할 수 있다. <br>
하지만 하위 버전 JDK에서 상위 버전의 클래스 파일을 실행할 수는 없다.

```java
public class TestClass {
    private int m;
    
    public int inc() {
        return m + 1;
    }
}
```

이 프로그램을 JDK 17로 컴파일해, 클래스 파일을 십육진수 편집기로 열어보면 다음과 같다. <br>
첫 번째 4바이트에서 0XCAFEBABE 값을 확인할 수 있다. 5〜6번째 바이트는 마이너 버전인 0x0000이고, 이어서 메이저 버전인 0x003D가 이어진다.

<img width="793" alt="Image" src="https://github.com/user-attachments/assets/db1b673e-57f8-45b7-a654-e47bfc999813" />

### 상수 풀

상수 풀은 클래스 파일의 자원 창고라 할 수 있다. 클래스 파일 구조에서 다른 클래스와 가장 많이 연관된 부분이다. <br>
상수 풀에 들어 있는 상수의 수는 고정적이지 않으므로 상수 풀 항목들에 앞서 항목 개수를 알려 주는 u2 타입 데이터가 필요하다. <br>
자바 언어의 관례상 이 개수를 셀 때는 0이 아닌 1부터 시작한다. <br>
아래 그림에서 TestClass 클래스의 상수 풀 크기는 십육진수로 0x0013인데, 십진수로 19에 해당한다. 즉 상수 풀에는 상수가 18개 존재한다.

<img width="798" alt="Image" src="https://github.com/user-attachments/assets/cb29df21-d70c-4ba7-bf66-f38db1933bca" />

상수 풀에 담기는 상수 유형은 리터럴과 심벌 참조 두 가지다. <br>
리터럴은 자바 언어 수준에서 이야기하는 상수(final로 선언된 문자열이나 상수)와 비슷한 개념이다. <br>
심벌 참조는 컴파일과 관련된 개념으로, 다음 유형의 상수들이 포함된다.

- 모듈에서 익스포트하거나 임포트하는 패키지
- 클래스와 인터페이스의 완전한 이름
- 필드 이름과 서술자
- 메서드 이름과 서술자
- 메서드 핸들과 메서드 타입
- 동적으로 계산되는 호출 사이트와 동적으로 계산되는 상수

가상 머신은 클래스 파일을 로드할 때 상수 풀에서 해당 심벌 참조들을 가져온다. <br>
그런 다음 클래스가 생성되거나 구동할 때 해석하여 실제 메모리 주소로 변환한다.

<img width="728" alt="Image" src="https://github.com/user-attachments/assets/23f8c027-288e-4cf1-82d1-5aba6ebbe3f4" />

### 접근 플래그

상수 풀 다음의 2바이트는 현재 클래스(또는 인터페이스)의 접근 정보를 식별하는 접근 플래그다. <br>
현재 클래스 파일이 표현하는 대상이 클래스인지, 인터페이스인지, public인지, abstract인지, 클래스인 경우 final인지 등의 정보가 담긴다. 

<img width="708" alt="Image" src="https://github.com/user-attachments/assets/a2cde63d-2c34-4a1d-a8dc-4896a8bec8d4" />

TestClass를 예로 보면, 인터페이스, 열거형, 애너테이션, 모듈이 아닌 일반 자바 클래스이며, public이고 final과 abstract는 아니다. <br>
JDK 1.2 이상을 사용했으므로 ACC_PUBLIC과 ACC_SUPER 플래그는 true이고, 나머지 7개 플래그는 모두 false여야 한다.

### 클래스 인덱스, 부모 클래스 인덱스, 인터페이스 인덱스

현재 클래스 인덱스(this_class)와 부모 클래스 인덱스(superclass), 인터페이스 인덱스 컬렉션(interfaces)이 존재한다. <br>
이러한 정보는 클래스 파일의 상속 관계를 규정한다. <br>
클래스 인덱스와 부모 클래스 인덱스는 각각 현재 클래스와 부모 클래스의 완전한 이름을 결정하는 데 쓰인다. 자바 언어는 다중 상속을 허용하지 않으므로 부모 클래스 인덱스는 하나뿐이다.

<img width="766" alt="Image" src="https://github.com/user-attachments/assets/9d04e9cf-7a0f-45a2-a3cc-deb4638f00e9" />

### 필드 테이블

필드 테이블은 인터페이스나 클래스 안에 선언된 변수들을 설명하는데 쓰인다. <br>
자바 언어에서 필드란 클래스 변수와 인스턴스 변수를 뜻한다. 메서드 안에 선언된 지 역 변수는 필드가 아니다. <br>
필드는 필드에 접근할 수 있는 범위 제한(public, private...), 인스턴스 변수와 클래스 변수의 구분(static), 불변 여부(final), 휘발성(volatile), 직렬화 시 포함 여부, 데이터 타입, 필드 이름이 있다.

<img width="743" alt="Image" src="https://github.com/user-attachments/assets/da3c4aa1-de92-4875-aac4-7c57403d7151" />

### 메서드 테이블

클래스 파일에서 메서드 저장 형태는 필드 저장 형태와 거의 같다.

```
method_info {
    u2                  access_flags;
    u2                  name_index;
    u2                  descriptor_index;
    u2                  attributes_count;
    attribute_info      attributes[attributes_count];
}
```

메서드 정의는 접근 플래그, 이름 인덱스, 서술자 인덱스만으로 명확하게 표현된다. <br>
그런데 메서드 본문의 코드는, javac 컴파일러에 의해 바이트코드 명령어로 변환된 후, 메서드 속성 테이블 컬렉션의 Code 속성에 따로 저장된다.

### 속성 테이블

클래스 파일, 필드 테이블, 메서드 테이블, Code 속성, 레코드 구성 요소는 모두 특정 시나리오에서 특정한 정보를 설명하기 위해 고유한 속성 테이블을 포함할 수 있다. <br>
클래스 파일의 다른 데이터 항목들은 순서, 길이' 내용을 엄격하게 지켜야 하는 데 반해 속성 테이블 컬렉션은 제약이 살짝 느슨하며 순서에도 엄격하지 않다. <br>
자바 가상 머신 명세는 기존 속성 이름과 중복되지 않는 한, 자체 제작한 컴파일러가 새로운 속성 정보를 속성 테이블에 추가할 수 있도록 허용한다. <br>
속성 테이블이 만족해야 하는 공통 구조는 다음과 같다.

```
attribute_info {
    u2  attribute_name_index;
    u4  attribute_length;
    u1  info[attribute_length];
}
```

#### code 속성

자바 프로그램의 메서드 본문 코드는 자바 컴파일러에 의해 최종적으로 바이트코드 명령어로 변환된 후 Code 속성에 저장된다. <br>
Code 속성은 메서드 테이블의 속성 컬렉션에 자리하지만, 모든 메서드 테이블에 포함되는 것은 아니다. 예컨대 인터페이스나 추상 클래스의 추상 메서드에는 Code 속성이 없다. <br>
메서드 테이블에 Code 속성이 있다면 구조는 다음과 같다.

<img width="606" alt="Image" src="https://github.com/user-attachments/assets/5bd90745-92da-45a9-8db9-fdb44ced9bfd" />

#### Exceptions 속성

Exceptions 속성은 메서드에서 throw될 수 있는 검사 예외, 즉 메서드 설명에서 throws 키워드 뒤에 나오는 예외들을 나열하는 기능을 한다. <br>
구조는 다음과 같다

```
Exceptions_attribute {
    u2      attribute_name_index;
    u4      attribute_length;
    u2      number_of_exceptions;   // 이 메서드가 던질 수 있는 검사 예외 개수
    u2      exception_index_table[number_of_exceptions]
}
```

#### LineNumberTable 속성

자바 소스 코드의 줄 번호와 바이트코드의 줄 번호 사이의 대응 관계를 설명하는 속성이다. <br>
프로그램을 실행하는 데 꼭 필요한 속성은 아니지만 클래스 파일에 기본적으로 생성된다. <br>
이 속성을 생성하지 않는다면, 예외가 발생했을 때 오류를 일으킨 코드의 줄 번호가 스택 추적 정보에 나타나지 않는다.

#### LocalVariableTable과 LocalVariableTypeTable 속성

LocaWariableTable은 스택 프레임에 있는 지역 변수 테이블 안의 변수와 자바 소스 코드에 정의된 변수 사이의 관계를 설명하는 속성이다. <br>
이 속성을 생성하지 않으면 다른 사람이 이 메서드를 참조할 때 매개 변수 이름을 알 수 없게 된다.

local_variable_table 항목은 소스 코드에서 스택 프레임과 지역 변수 사이의 관계를 나타낸다. <br>

#### SourceFile과 SourceDebugExtension 속성

SourceFile 속성에는 클래스 파일을 생성한 자바 소스 파일 이름이 기록된다. <br>
자바에서는 클래스 이름과 파일 이름이 대체로 같다. 단, 내부 클래스처 럼 특수한 경우는 예외다. <br>
이 속성을 생성하지 않으면 예외를 일으킨 코드가 어느 파일에 담겨 있는지가 스택 추적 정보에 나타나지 않는다.

SourceDebugExtension 속성은 컴파일러에 의해, 또는 동적으로 생성된 클래스에 개발자를 위한 사용자 정의 정보를 쉽게 추가할 수 있도록 설계된 속성이다. <br>
SourceDebugExtension 속성을 이용하면 예외 스택 추적 정보에서 JSP 파일의 줄 번호를 찾는 등, JSR 45 표준이 새로 정의한 디버깅 정보를 담을 수 있다.

#### ConstantValue 속성

정적 변수에 값을 자동으로 할당하도록 가상 머신에 알린다. static 키워드로 선언된 변수(클래스 변수)에만 이 속성이 붙는다. <br>
int x = 123과 static int x = 123 같은 코드는 모두 자바 프로그램에서 매우 흔히 볼 수 있다. <br>
하지만 가상 머신이 두 형태의 변수를 할당하는 방식과 시기는 전혀 다르다. <br>
인스턴스 변수 할당은 인스턴스 생성자인 <init>()에서 수행한다. 반면 클래스 변수는 클래스 생성자인 <clinit>()를 사용하거나 Constantvalue 속성을 사용하는 방법 중 선택할 수 있다.

#### InnerClasses 속성

내부 클래스와 호스트 클래스 사이의 연결 관계를 기록한다. 내부 클래스를 정의하면 컴파일러가 InnerClasses 속성을 자동으로 생성한다.

#### Deprecated와 Synthetic 속성

두 속성은 모두 플래그 타입의 불（Boolean） 속성이다. <br>
Deprecated 속성은 클래스, 필드 또는 메서드를 프로그램 작성자가 폐기 대상으로 지정했음을 나타낸다. 소스 코드에서 ©deprecated 애너테 이션을 달아 설정할 수 있다. <br>
Synthetic 속성은 컴파일러가 추가한 필드나 메서드임을 나타낸다.

#### StackMapTable 속성

StackMapTable은 Code 속성의 attributes 테이블에 자리하는 상당히 복잡한 가변 길이 속성이다. <br>
이 속성은 가상 머신이 클래스를 로드할 때 바이트코드 검증 단계에서 타입 검증기가 활용한다. <br>
이전 JDK에서는 데이터 흐름을 분석하여 타입을 추론했는데, 클래스 로딩 성능을 떨어뜨리는 주된 요인이었다. <br>
타입 검사 기반의 새로운 검증기는 런타임에 타입을 추론하기 위해 데이터 흐름을 분석하던 논리적 적법성 확인 단계를 생략한다. <br>
먼저 컴파일 단계에서 일련의 검증 타입을 클래스 파일에 기록해 둔다. 그런 다음 런타임에는 타입을 추론하는 대신 이 검증 타입을 바로 확인한다. 그 덕분에 바이트코드 검증 성능이 크게 개선되었다.

#### Signature 속성

JDK 5 때 제네릭을 지원하기 위해 추가된 Signature 속성은 클래스의 속성 테이블, 필드 테이블, 메서드 테이블에 선택적으로 등장할 수 있다. 길이는 일정하다. <br>
이 속성은 클래스, 인터페이스, 초기화 메서드, 기타 클래스 멤버가 타입 변수나 매개 변수화 타입을 포함할 경우 제네릭 시그너처 정보를 담기 위해 이용한다. <br>
제네릭 타입 정보를 기록하는 데 이 속성이 필요한 이유는 자바 언어가 제네 릭을 소거법으로 구현했기 때문이다. <br>
즉, 컴파일 후 바이트코드에서는 어떠한 제네릭 정보도 찾아볼 수 없다.

#### BootstrapMethods 속성

JDK 7 때 추가된 BootstrapMethods는 복잡한 가변 길이 속성으로, 클래스 파일의 속성 테이블에 위치한다. <br>
이 속성에는 invokedynamic 명령어가 참조하는 부트스트랩 메서드 한정자가 담긴다.

#### MethodParameters 속성

메서드 테이블에서 사용되는 가변 길이 속성으로, 메서드가 받는 매개 변수 각각의 이름과 정보를 기록한다. <br>
JDK 8에서는 Methodparameters 속성을 새로 도입하여 컴파일러가 매개변수 이름을 클래스 파일에 기록할 수 있게 했다. 

#### 모듈화 관련 속성

JDK 9에서는 모듈 도입이라는 큰 변화가 있었다. 모듈 설명 파일인 module-info, java는 결국 독립된 클래스 파일로 컴파일되어 저장된다. <br>
Module은 매우 복잡한 가변 길이 속성이다. 모듈 이름, 버전, 플래그 정보는 물론 모듈에 정의된 requirements, exports, opens, uses, provides 요구 사항의 내용을 모두 담는다.

#### 런타임 애너테이션 관련 속성

JDK 5에서 자바 언어 구문에 몇 가지 큰 개선이 이루어졌는데, 그중 하나가 바로 애너테이션이다. <br>
이때 애너테이션 정보를 담기 위해 새로운 속성 네 가지가 클래스 파일에 동시에 추가되었다. (RuntimeVisibleAnnotations, RuntimeInvisibleAnnotations, RuntimeVisibleParameterAnnotations, RuntimelnvisibleParameterAnnotations) <br>
다시 JDK 8에 와서는 자바 언어에서 애너테이션 활용 범위가 확장되었다. 정확히는 타입 애너테이션이 도입되면서 클래스 파일 구조에 RuntimeVisibleTypeAnnotations와 RuntimelnvisibleTypeAnnotations 속성이 주가되었다.

#### Record 속성

레코드는 불변 객체를 쉽게 생성할 수 있도록 해 주는 클래스로＞JDK 16부터 정식으로 도입되었다. <br>
Record 속성이 있다면 현재 클래스가 레코드 클래스임을 뜻한다.

#### PermittedSubclasses 속성

JDK 17부터 정식 도입된 봉인된 클래스（봉인 인터페이스）를 지원하기 위한 속성이다. <br>
봉인된 클래스는 자신을 직접 확장할 수 있는 대상을 명시한다. 그 외 클래스에서는 직접 확장할 수 없다. <br>
PermittedSubclasses 속성은 봉인된 클래스가 허용하는 서브클래스 정보를 담으며 구조는 다음과 같다.

## 바이트코드 명령어 소개

자바 가상 머신의 명령어는 특정 작업을 뜻하는 바이트 길이의 숫자인 연산 코드와 해당 작업에 필요한 0개 이상의 피연산자로 이루어진다. <br>
명령어 대부분이 피연산자 없이 연산 코드 하나로 구성되며, 피연산자는 피연산자 스택 에 저장된다. <br>
바이트코드 명령어 집합은 연산 코드의 길이가 1바이트로 제한되기 때문에, 최대 256개의 연산 코드만 표현할 수 있다. <br>
또한 클래스 파일 구조에서는 컴파일된 코드에 들어 있는 피연산자의 길이 정렬을 허용하지 않는다. <br>
따라서 1바이트가 넘는 데이터를 처리할 때는 가상 머신이 런타임에 해당 바이트들을 특정 구조로 재구성해야 한다.

### 바이트코드와 데이터 타입들

자바 가상 머신 명령어 집합을 보면 대다수 명령어 자체에 해당 연산에 필요한 데이터의 타입 정보가 포함되어 있다. <br>
예컨대 iload 명령어는 지역 변수 테이블에서 피연산자 스택으로 int 타입 데이터를, fload 명령어는 float 타입 데이터를 읽어들인다.

<img width="762" alt="Image" src="https://github.com/user-attachments/assets/06d45e8f-9a83-43d3-9b4e-a4f93a801c4a" />

### 로드와 스토어 명령어

로드와 스토어 명령어는 스택 프레임의 지역 변수 테이블과 피연산자 스택 사이에서 데이터를 주고받는 데 쓰인다. <br>
데이터를 담는 역할의 피연산자 스택과 지역 변수 테이블은 주로 로드와 스토어 명령어로 조작한다.

- 지역 변수를 피연산자 스택으로 읽어오기: iload, iload_<n>, lload, lload_<n>, fload, fload_<n>.....
- 피연산자 스택의 값을 지역 변수 테이블에 저장하기: istore, istore_<n>, lstore, lstore_<n>....
- 상수를 피연산자 스택으로 읽어오기: bipush, sipush, ldc, ldc_w, ldc2_w....
- 더 넓은 인덱스를 사용하여 더 많은 지역 변수에 접근하거나 더 큰 피연산자에 접근하기: wide

### 산술 명령어

산술 명령어들은 피연산자 스택의 값 두 개를 이용해 특정한 산술 연산을 수행하고, 결괏값을 다시 피연산자 스택의 맨 위에 저장한다. <br>
이 명령어들은 대체로 정수 데이터를 다루는 부류와 부동 소수점 데이터를 다루는 부류로 구분할 수 있다. <br>
byte, short, char, boolean 타입을 직접 지원하는 산술 연산자는 없기 때문에, int 타입용 명령어를 대신 이용한다.

- 더하기: iadd, ladd, fadd, dadd
- 빼기: isub, lsub, fsub, dsub
- 곱하기: imul, lmul, fmul, dmul
- 나누기: idiv, ldiv, fdiv, ddiv
- 나머지: irem, lrem, frem, drem
- 부정: ineg, lneg, fneg, dneg
- 시프트: ishl, ishr, iushr, lshl, lshr, lushr
- 비트 단위 OR: ior, lor
- 비트 단위 AND: iand, land
- 비트 단위 XOR: ixor, lxor
- 지역 변숫값 증가: iinc
- 비교: dcmpg, dcmpl, fcmpg, fcmpl, lcmp

### 형 변환 명령어

형 변환 명령어는 숫자 타입 데이터를 다른 숫자 타입으로 변환한다. <br>
주로 개발자가 소스 코드에 명시한 형 변환을 구현하거나, 주어진 피연산자의 데이터 타입을 처리하는 전용 연산 코드가 없는 경우를 처리하는데 이용된다. <br>
데이터 타입의 표현 범위가 넓어지는 경우는 변환 명령어를 명시하지 않아도 자바 가상 머신이 알아서 수행해 준다. 이 변환에서는 정보를 잃을 게 없으니 항상 안전하다. <br>
반대로 표현 범위가 축소될 때는 형 변환 명령어를 반드시 명시해야 한다. 축소 변환 시에는 결과의 부호나 단위가 바뀌거나 수치 정밀도가 떨어질 가능성이 있다.

### 객체 생성과 접근 명령어

클래스 인스턴스와 배열도 객체다. 하지만 자바 가상 머신은 이 두 가지 객체의 생성과 조작에 서로 다른 바이트코드 명령어를 사용한다. <br>
생성된 객체나 배열 인스턴스의 필드들 또는 배열의 원소들은 객체 접근 명령어를 이용해 얻어 올 수 있다.

- 클래스 인스턴스 생성: new
- 배열 생성: newarray, anewarray, multianewarray
- 클래스의 필드와 인스턴스의 필드 접근: getfield, putfield, getstatic, putstatic
- 배열 원소를 피연산자 스택으로 읽어오기: baload, caload, saload, iaload, laload, faload, daload, aaload
- 피연산자 스택의 값을 배열 원소에 저장: bastore, castore, sastore, iastore, fastore, dastore, aastore
- 배열 길이 얻기: arraylength
- 클래스 인스턴스 또는 배열의 타입 확인: instanceof, checkast

### 피연산자 스택 관리 명령어

- 피연산자 스택에서 최상위 원소 한 개 또는 두 개 꺼내지: pop, pop2
- 스택의 최상위 값 한 개 또는 두 개를 복제한 다음, 복제된 값을 스택 최상위에 다시 넣기: dup, dup2, dup_x1, dup2x1
- 스택의 최상에 있는 값 두개를 치환: swap

### 제어 전이 명령어

프로그램의 실행 흐름을 조건에 따라 또는 무조건적으로 지정한 위치의 명령어로 이동시킨다. <br>
개념적으로 보면 PC 레지스터의 값을 조건부로 또는 무조건적으로 변경한다고 이해할 수 있다.

- 조건 분기: ifeq, iflt, ifle, ifne .....
- 복합 조건 분기: tableswitch, lookupswitch
- 무조건 분기: goto, goto_w, jsr, jsr_w, ret

### 메서드 호출과 반환 명령어

- invokevirtual: 객체의 인스턴스 메서드를 호출하며, 객체의 실제 타입에 따라 디스패치한다.
- invokeinterface: 인터페이스 메서드를 호출하며, 런타임에 이 인터페이스 메서드를 구현한 객체를 검색하여 적절한 메서드를 찾는다.
- invokespecial: 인스턴스 초기화 메서드, private 메서드, 부모 클래스의 메서드를 포함하여 특수 처 리가 필요한 일부 인스턴스 메서드를 호출한다.
- invokestatic: 클래스 메서드（static 메서드）를 호출한다.
- invokedynamic: 런타임에 호출 사이트 한정자가 참조하는 메서드를 동적으로 찾아 호출한다.

### 예외 처리 명령어

자바 프로그램에서 throw 문으로 예외를 명시적으로 던지는 작업은 athrow 명령어로 구현된다. <br>
자바 가상 머신은 예외 처리（catch 문）를 바이트코드 명령어 대신 예외 테이블을 이용해 구현한다.

### 동기화 명령어

가상 머신은 메서드 상수 풀 안의 메서드 테이블에 있는 ACC_SYNCHR0NIZED 접근 플래그를 확인하여 동기화된 메서드인지 알 수 있다. <br>
메서드가 호출되면 호출 명령어는 우선 해당 메서드의 ACC_SYNCHR0NIZED 접근 플래그가 설정되어 있는지 확인한다. <br>
설정되어 있다면 실행 스레드가 메서드 본문으로 진입하기 전에 모니터를 획득해야 한다. <ㅠㄱ>
본문 실행을 마치면 정상 완료 여부와 관계없이 모니터를 해제한다. 한 스레드가 메서드를 실행하는 동안 다른 스레드는 동일한 모니터를 얻을 수 없다.












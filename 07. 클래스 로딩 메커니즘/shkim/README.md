# 클래스 로딩 메커니즘

자바 가상 머신은 클래스를 설명하는 데이터를 클래스 파일로부터 메모리로 읽어 들이고 그 데이터를 검증, 변환, 초기화하고 나서 최종적으로 가상 머신이 곧바로 사용할 수 있는 자바 타입을 생성한다. <br>
이 과정을 가상 머신의 클래스 로딩 메커니즘이라고 한다. <br>
컴파일 시 링크까지 해야 하는 언어들과 달리 자바 언어에서는 클래스 로딩, 링킹, 초기화가 모두 프로그램 실행 중에 이루어진다. <br>
그래서 자바 언어는 AOT 컴파일에 제약이 생기고 클래스 로딩을 거치느라 실행 성능이 살짝 떨어진다. 하지만 이는 자바 애플리케이션의 높은 확장성과 유연성을 가능케 하는 이점으로도 작용한다.

자바가 동적 확장 언어 기능을 제공할 수 있는 것은 런타임에 이루어지는 동적 로딩과 동적 링킹 덕분이다. <br>
예를 들어 애플리케이션을 인터페이스 중심으로 작성해 두면 실제 구현 클래스를 결정하는 일은 실행 시까지 미룰 수 있다. <br>
또한 클래스 로더를 활용하면 실행 중인 프로그램의 코드 일부를 네트워크를 통해 바이너리 스트림으로 읽어 올 수 있다.

## 클래스 로딩 시점

<img width="695" alt="Image" src="https://github.com/user-attachments/assets/64e58376-d97e-4a97-8dfc-11638b987eff" />

로딩, 검증, 준비, 초기화, 언로딩은 반드시 순서대로 진행해야 한다. <br>
반면 해석 단계는 그렇지 않아서 때에 따라서는 초기화 후에 시작할 수 있다. <br>
이는 자바 언어의 런타임 바인딩을 지원하기 위해서다.

클래스 로딩 과정의 첫 단계인 로딩을 정확히 어떤 상황에서 시작해야 하는지 명시하지 않았다. <br>
반면 초기화 단계는 즉시 시작되어야 하는 상황 여섯가지를 엄격히 규정했다.

1. 바이트코드 명령어인 new, getstatic, putstatic, invokestatic을 만났을때 해당 타입이 아직 초기화되어 있지 않다면 초기화를 촉발한다. <br>
   자바 코드에서 이 명령어를 생산하는 시나리오는 다음과 같다.
   1. new 키워드로 객체의 인스턴스 생성
   2. 타입의 정적 필드를 읽거나 설정 (단, final로 지정된 정적 필드는 컴파일타임에 상수 풀에 채워지므로 제외)
   3. 타입의 정적 메서드 호출
2. Class 클래스나 java.lang.reflect 패키지 등 표준 클래스 라이브러리에서 제공하는 리플렉션 메서드를 사용할때 해당 타입이 아직 초기화되어 있지 않다면 초기화를 촉발한다.
3. 클래스를 초기화할 때 상위 클래스가 초기화되어 있지 않다면 상위 클래스 초기화를 촉발한다.
4. 가상 머신은 구동 직후 사용자가 지정한 메인 타입을 찾아 실행한다.
5. REF_getStatic, REF_putStatic, REF_invokeStatic, REF_newInvokeSpecial 타입 메서드 핸들을 해석해 얻은 java.lang.invoke.MethodHandle 인스턴스를 호출할때 해당하는 클래스가 초기화되어 있지 않다면 초기화를 촉발한다.
6. 인터페이스에 디폴트 메서드를 정의했다면, 해당 인터페이스를 직간접적으로 구현한 클래스가 초기화될 때 인터페이스부터 초기화한다.

이 시나리오들이 설명하는 동작을 타입에 대한 **능동 참조**라고 한다. <br>
반대로 타입 초기화를 촉발하지 않는 그 외의 모든 참조 방식은 **수동 참조**라고 한다.

```java
class SuperClass {
    static {
        System.out.println("상위 클래스 초기화");
    }
    
    public static int value = 123;
}

class SubClass extends SuperClass {
    static {
        System.out.println("하위 클래스 초기화");
    }
}

public class NotInitialization_1 {
    public static void main(String[] args) {
        System.out.println(SubClass.value);
    }
}
```

이 코드를 실행하면 "상위 클래스 초기화"는 출력되지만 "하위 클래스 초기화"는 출력되지 않는다. <br>
정적 필드를 참조할 때는 필드를 직접 정의한 클래스만 초기화된다. <br>
이때 하위 클래스의 로딩과 검증 단계를 촉발할지 여부는 가상 머신을 구현하기 나름이다. 

<br>

```java
public class NotInitialization_2 {
    public static void main(String[] args) {
        SuperClass[] sca = new SuperClass[10];
    }
}
```

이 코드는 실행해도 "상위 클래스 초기화"가 출력되지 않는다. <br>
자바 가상 머신이 이 클래스를 생성하는 바이트코드 명령어는 anewarray다. <br>
이 클래스의 정체는 원소 타입이 SupserClass인 일차원 배열이다.

<br>

```java
class Constclass {
    static {
        System.out.println("Constclass 초기화!");
    }
    
    public static final String HELLO_WORLD = "hello world";
}

public class NotInitialization_3 {
    public static void main(String[] args) {
        System.out.printin(ConstClass.HELLO_WORLD);
    }
}
```

코드를 실행해도 "ConstClass 초기화!"는 출력되지 않는다. <br>
ConstClass 클래스에 정의된 상수인 HELLO_WORLD를 이용하고 있지만, 컴파일 과정에서 상수 전파 최적화가 이루어지기 때문이다. <br>
그 결과 상수의 값 "hello world"는 NotInitialization_3 클래스의 상수풀에 직접 저장되고, ConstClass.HELLO_WORLD를 참조하는 코드는 NotInitialization_3 클래스 자체의 상수풀을 이용하도록 변경된다.

## 클래스 로딩 처리 과정

### 로딩

자바 가상 머신은 로딩 단계에서 다음 세 가지 작업을 수행해야 한다.

1. 완전한 이름을 보고 해당 클래스를 정의하는 바이너리 바이트 스트림을 가져온다. 
2. 바이트 스트림으로 표현된 정적인 저장 구조를 메서드 영역에서 사용하는 런타임 데이터 구조로 변환한다.
3. 로딩 대상 클래스를 표현하는 java.lang.Class 객체를 힙 메모리에 생성한다. 이 Class 객체는 애플리케이션이 메서드 영역에 저장된 타입 데이터를 활용할 수 있게 하는 통로가 된다.


로딩 단계가 끝나면 바이너리 바이트 스트림은 자바 가상 머신이 정의한 형식에 맞게 메서드 영역에 저장된다. <br>
타입 정보를 메서드 영역에 올바르게 저장한 다음에는 해당 java.lang.Class 객체를 자바 힙에 초기화한다. <br>
로딩 단계와 링킹 단계의 일부 동작은 서로 중첩되어 진행된다.  즉, 로딩 단계에서 시작한 작업들이 완료되기 전에 링킹 단계도 시작될 수 있다.

### 검증

검증의 목적은 두가지다.

1. 클래스 파일의 바이트 스트림에 담긴 정보가 자바 가상 머신 명세에서 규정한 모든 제약을 만족하는지 확인한다.
2. 이 정보를 코드로 변환해 실행했을 때 자바 가상 머신 자체의 보안을 위협하지 않는지 확인한다.

### 준비

준비는 클래스 변수를 메모리에 할당하고 초깃값을 설정하는 단계다. <br>
준비 단계에서는 인스턴스 변수가 아닌 클래스 변수만 할당된다. 인스턴스 변수는 객체가 인스턴스화될 때 객체와 함께 자바 힙에 할당된다. <br>
또한 클래스 변수에 할당하는 초깃값은 해당 데이터 타입의 제로 값이다.

```java
public static int value = 123;
```

준비 단계를 마친 직후 value 변수에 할당되어 있는 초깃값은 123이 아닌 0이다. <br>
123을 할당하는 putstatic 명령어는 클래스 생성자인 <clinit>（） 메서드에 포함되며, 준비 단계에서는 어떠한 자바 메서드도 아직 실행되지 않은 상태이기 때문이다. <br>
123을 할당하는 일은 클래스 초기화 단계에 가서야 이루어진다.

일반적인 경우에는 초깃값이 모두 0이지만 특수한 경우도 있다. <br>
클래스 필드의 필드 속성 테 이블에 ConstantValue 속성이 존재한다면, 준비 단계에서 변수의 초깃값으로 ConstantValue 속성이 지정한 값을 할당한다. <br>
아래 코드를 컴파일하면 javac가 value 변수를 위한 ConstantValue 속성을 생성한다. <br>
그러면 가상 머신은 준비 단계 때 ConstantValue에 설정된 값인 123을 value에 할당할 것이다.

```java
public static final int value = 123;
```

### 해석

해석은 자바 가상 머신이 상수 풀의 심벌 참조를 직접 참조로 대체하는 과정이다. <br>
클래스 파일에서 CONSTANT_Class_info, CONSTANT_Fieldref_info, CONSTANT_Methodref_info 등이 바로 심벌 참조다.

- 심벌 참조: 몇 가지 심벌로 참조 대상을 설명한다. 여기서 심벌은 대상을 명확하게 지칭하는 데 이용될 수 있는 모든 형태의 리터 럴이 될 수 있다. <br>
  심벌 참조는 가상 머신이 구현한 메모리 레이아웃과는 아무런 관련이 없다. 참조 대상이 반드시 가상 머신의 메모리에 로드되어 있을 필요도 없다.
- 직접 참조: 포인터, 오프셋 또는 대상의 위치를 간접적으로 가리키는 핸들이다. 직접 참조는 가상 머신에 구현된 메모리 레이아웃과 밀접하게 관련된다. 따라서 똑같은 심벌 참조로부터 변환했더라도 직접 참조는 가상 머신에 따라 달라지는 게 보통이다.

### 초기화

초기화는 클래스 로딩의 마지막 단계다. 초기화 단계에 들어서면 자바 가상 머신이 드디어 사용자 클래스에 작성된 자바 프로그램 코드를 실행하기 시작한다. <br>
앞서 준비 단계에서는 모든 변수에 시스템이 정의한 초깃값인 0을 할당했다. 반면 초기화 단계에서는 클래스 변수와 기타 자원을 개발자가 프로그램 코드에 기술한 대로 초기화한다.

## 클래스 로더

자바 가상 머신 설계진은 필요한 클래스를 얻는 방법을 애플리케이션이 정할 수 있기를 원했다. <br>
그래서 클래스 로딩 단계 중 완전한 이름을 보고 해당 클래스를 정의하는 바이너리 바이트 스트림 가져오기를 가상 머신 외부에서 수행하도록 했다. <br>
이 역할을 맡은 코드를 클래스 로더라고 한다.

### 클래스와 클래스 로더

클래스 로더는 당연하게도 클래스를 로딩하는 일을 하지만 그 일이 전부는 아니다. <br>
각 클래스 로더는 독립적인 클래스 이름 공간을 지니 기 때문에 클래스 로더를 빼놓고는 특정 클래스가 자바 가상 머신에서 유일한지 판단할 수 없다. <br>
어떤 두 클래스가 '동치인가' 여부는 두 클래스 모두 같은 클래스 로더로 로드했을때만 의미가 있다.

### 부모 위임 모델

<img width="502" alt="Image" src="https://github.com/user-attachments/assets/f873910a-3b8a-402d-af94-b73328699d25" />

- 부트스트랩 클래스 로더: JAVA一HOME/lib 디렉터 리나 -Xbootclasspath 매개 변수로 지정한 경로에 위치한 파일들과 자바 가상 머신이 클래스 라이브러리로 인식하는 파일들을 로드하는 일을 책임진다.
- 확장 클래스 로더: JAVA_HOME/lib/ext 디렉터 리 또는 java.ext.dirs 시스템 변수로 지정한 경로의 클래스 라이브러리들을 로드하는 역할을 한다. <br>
  '확장' 클래스 로더라는 이름에서 유추할 수 있듯이 자바 시스템의 클래스 라이브러리를 확장하는 메커니즘이다.
- 애플리케이션 클래스 로더: 클래스패스상의 클래스 라이브러리들을 로드하는 역할을 하며, 개발자가 자바 코드에서 직접 사용할 수 있다. <br>
  클래스 로더를 따로 만들어 이용하지 않는 경우 이 로더가 기본 클래스 로더가 된다.

JDK8까지의 자바 애플리케이션들은 이 세 클래스 로더가 적절히 협력하여 로딩을 책임진다. <br>
그리고 필요시 사용자가 직접 만든 클래스 로더를 추가할 수 있다. <br>
사용자 정의 클래스 로더는 주로 로컬 디스크 외에 클래스 파일을 얻을 수 있는 위치를 추가하거나 클래스 격리 등의 기능을 구현하는 데 이용한다. <br>

## 자바 모듈 시스템

JDK9에 도입된 모듈 시스템은 JAR 패키지같은 단순한 코드 컨테이너가 아니라, 모듈화라는 '자유롭게 설정 가능한 캡슐화 격리 메커니즘'을 만들기 위해 자바 가상 머신은 클래스 로딩 아키텍처를 적절히 변형했다.
자바 모듈 정의에는 코드 외에 다음 내용이 포함된다.

- requires: 다른 모듈에 대한 의존성 목록
- exports: 다른 모듈에서 사용할 수 있는 패키지 목록
- open: 다른 모듈에서 리플렉션 AP［로 접근할 수 있는 패키지
- uses: 현재 모듈이 사용할 서비스 목록
- provides: 다른 모듈에 제공하는 서비스 목록

DK 9부터는 모듈이 의존하는 다른 모듈들을 명시할 수 있어서, 필요한 의존성이 모두 갖춰졌는지 애플리케이션 개발 단계에서 확인할 수 있다. <br>
의존성이 누락되었다면 애플리케이션은 시작 자체를 못하기 때문에 런타임 예외를 상당 부분 피할 수 있다. <br>
자바 모듈은 pubilc 타입중에서도 외부 모듈에 공개할 타입을 따로 명시하게 함으로써 접근 권한을 더 세분화해 관리한다. 이러한 접근 통제는 주로 클래스 로딩 과정에서 이루어진다.








